name: Turbo

on:
  pull_request:
  push:
    branches:
      - main
  merge_group:

concurrency:
  group: ${{ github.event_name == 'pull_request' && format('pr-{0}', github.event.pull_request.number) || (github.event_name == 'merge_group' && format('merge-queue-{0}', github.run_id) || 'staging') }}
  cancel-in-progress: ${{ github.event_name == 'pull_request' }}

jobs:
  # Prepare: detect changes and set job-ref identifier
  prepare:
    runs-on: ubuntu-latest
    container:
      image: ghcr.io/vm0-ai/vm0-toolchain:20260203
    outputs:
      job-ref: ${{ steps.set-job-ref.outputs.job-ref }}
      web-preview-url: ${{ steps.preview-urls.outputs.web-url }}
      web-changed: ${{ steps.detect.outputs.web-changed }}
      site-changed: ${{ steps.detect.outputs.site-changed }}
      docs-changed: ${{ steps.detect.outputs.docs-changed }}
      cli-changed: ${{ steps.detect.outputs.cli-changed }}
      runner-changed: ${{ steps.detect.outputs.runner-changed }}
      platform-changed: ${{ steps.detect.outputs.platform-changed }}
      e2b-changed: ${{ steps.detect-e2b.outputs.e2b-changed }}
      cli-e2e-parallel-matrix: ${{ steps.cli-e2e-matrix.outputs.matrix }}
    steps:
      - uses: actions/checkout@v6
        with:
          fetch-depth: 0

      - name: Configure Git safe directory
        run: git config --global --add safe.directory /__w/vm0/vm0

      - name: Detect changes
        id: detect
        run: |
          echo "Checking for changes..."

          # Determine base ref based on event type
          if [ "${{ github.event_name }}" = "pull_request" ]; then
            BASE_REF=$(git merge-base ${{ github.event.pull_request.base.sha }} HEAD)
            echo "PR mode: comparing against merge base $BASE_REF"
          elif [ "${{ github.event_name }}" = "merge_group" ]; then
            BASE_REF="${{ github.event.merge_group.base_sha }}"
            echo "Merge queue mode: comparing against base $BASE_REF"
          else
            BASE_REF="HEAD^"
            echo "Main push mode: comparing against HEAD^"
          fi

          # Run changed.sh to get all package changes in one go
          CHANGES_JSON=$(./scripts/changed.sh $BASE_REF)

          # Parse JSON and set outputs for each app
          for app in $(ls turbo/apps); do
            # Get the package name from package.json
            if [ -f "turbo/apps/$app/package.json" ]; then
              PKG_NAME=$(jq -r '.name' "turbo/apps/$app/package.json")
              CHANGED=$(echo "$CHANGES_JSON" | jq -r ".\"$PKG_NAME\" // false")

              if [ "$CHANGED" = "true" ]; then
                echo "Changes detected in $app ($PKG_NAME)"
                echo "${app}-changed=true" >> $GITHUB_OUTPUT
              else
                echo "No changes in $app ($PKG_NAME)"
                echo "${app}-changed=false" >> $GITHUB_OUTPUT
              fi
            else
              echo "No package.json for $app, skipping"
              echo "${app}-changed=false" >> $GITHUB_OUTPUT
            fi
          done

      - name: Detect E2B template changes
        id: detect-e2b
        run: |
          # Determine base ref based on event type
          if [ "${{ github.event_name }}" = "pull_request" ]; then
            BASE_REF=$(git merge-base ${{ github.event.pull_request.base.sha }} HEAD)
          elif [ "${{ github.event_name }}" = "merge_group" ]; then
            BASE_REF="${{ github.event.merge_group.base_sha }}"
          else
            BASE_REF="HEAD^"
          fi

          # Check if E2B template files changed
          if git diff --name-only "$BASE_REF" HEAD | grep -q "^turbo/scripts/e2b/"; then
            echo "E2B template changes detected"
            echo "e2b-changed=true" >> $GITHUB_OUTPUT
          else
            echo "No E2B template changes"
            echo "e2b-changed=false" >> $GITHUB_OUTPUT
          fi

      - name: Set job-ref
        id: set-job-ref
        run: |
          if [ "${{ github.event_name }}" = "pull_request" ]; then
            echo "job-ref=pr-${{ github.event.pull_request.number }}" >> $GITHUB_OUTPUT
            echo "Job ref set to: pr-${{ github.event.pull_request.number }}"
          elif [ "${{ github.event_name }}" = "merge_group" ]; then
            echo "job-ref=" >> $GITHUB_OUTPUT
            echo "Job ref set to: (empty - merge_group will skip deployments)"
          else
            echo "job-ref=staging" >> $GITHUB_OUTPUT
            echo "Job ref set to: staging"
          fi

      - name: Set preview URLs
        id: preview-urls
        run: |
          JOB_REF="${{ steps.set-job-ref.outputs.job-ref }}"
          PREVIEW_DOMAIN="${{ vars.PREVIEW_DOMAIN }}"

          if [ -n "$PREVIEW_DOMAIN" ] && [ -n "$JOB_REF" ]; then
            echo "web-url=https://${JOB_REF}-www.${PREVIEW_DOMAIN}" >> $GITHUB_OUTPUT
            echo "Preview URL set to: https://${JOB_REF}-www.${PREVIEW_DOMAIN}"
          else
            echo "web-url=" >> $GITHUB_OUTPUT
            echo "Preview URL not set (PREVIEW_DOMAIN or job-ref is empty)"
          fi

      - name: Generate CLI E2E parallel test matrix
        id: cli-e2e-matrix
        shell: bash
        run: |
          # Scan test files and distribute them across chunks using load balancing
          # Dynamic chunk count: ~15 tests per chunk, max 10 chunks
          TESTS_PER_CHUNK=15
          MAX_CHUNKS=10

          # Count tests per file
          declare -A FILE_TESTS
          TOTAL_TESTS=0
          for f in e2e/tests/02-parallel/*.bats; do
            count=$(grep -c "^@test" "$f" 2>/dev/null || echo 0)
            FILE_TESTS["$f"]=$count
            TOTAL_TESTS=$((TOTAL_TESTS + count))
          done

          # Calculate number of chunks (min 1, max MAX_CHUNKS)
          NUM_CHUNKS=$(( (TOTAL_TESTS + TESTS_PER_CHUNK - 1) / TESTS_PER_CHUNK ))
          NUM_CHUNKS=$(( NUM_CHUNKS < 1 ? 1 : NUM_CHUNKS ))
          NUM_CHUNKS=$(( NUM_CHUNKS > MAX_CHUNKS ? MAX_CHUNKS : NUM_CHUNKS ))

          # Sort files by test count descending for better distribution
          mapfile -t SORTED_FILES < <(
            for f in "${!FILE_TESTS[@]}"; do
              echo "${FILE_TESTS[$f]} $f"
            done | sort -rn | cut -d' ' -f2
          )

          echo "Found ${#SORTED_FILES[@]} files with $TOTAL_TESTS total tests"
          echo "Creating $NUM_CHUNKS chunks (~$TESTS_PER_CHUNK tests each)"

          # Initialize chunk arrays and test counts
          declare -a CHUNK_FILES
          declare -a CHUNK_COUNTS
          for ((i=0; i<NUM_CHUNKS; i++)); do
            CHUNK_FILES[$i]=""
            CHUNK_COUNTS[$i]=0
          done

          # Distribute files using greedy load balancing (assign to least loaded chunk)
          for f in "${SORTED_FILES[@]}"; do
            tests=${FILE_TESTS[$f]}

            # Find chunk with minimum tests
            min_chunk=0
            min_count=${CHUNK_COUNTS[0]}
            for ((i=1; i<NUM_CHUNKS; i++)); do
              if [ ${CHUNK_COUNTS[$i]} -lt $min_count ]; then
                min_chunk=$i
                min_count=${CHUNK_COUNTS[$i]}
              fi
            done

            # Add file to that chunk
            if [ -n "${CHUNK_FILES[$min_chunk]}" ]; then
              CHUNK_FILES[$min_chunk]="${CHUNK_FILES[$min_chunk]} $f"
            else
              CHUNK_FILES[$min_chunk]="$f"
            fi
            CHUNK_COUNTS[$min_chunk]=$((CHUNK_COUNTS[$min_chunk] + tests))
          done

          # Build JSON array
          CHUNKS="["
          for ((i=0; i<NUM_CHUNKS; i++)); do
            if [ $i -gt 0 ]; then
              CHUNKS="$CHUNKS,"
            fi
            files="${CHUNK_FILES[$i]}"
            file_count=$(echo $files | wc -w)
            CHUNKS="$CHUNKS{\"index\":$((i+1)),\"files\":\"$files\"}"
            echo "Chunk $((i+1)): $file_count files, ${CHUNK_COUNTS[$i]} tests"
          done
          CHUNKS="$CHUNKS]"

          echo "matrix=$CHUNKS" >> $GITHUB_OUTPUT

  file-size-check:
    runs-on: ubuntu-latest
    # Skip for release-please commits (only version bumps and changelogs)
    if: "${{ github.event_name != 'push' || !startsWith(github.event.head_commit.message, 'chore: release') }}"
    steps:
      - uses: actions/checkout@v6
        with:
          fetch-depth: 0

      - name: Check file sizes
        run: |
          # Get changed files in PR
          if [ "${{ github.event_name }}" = "pull_request" ]; then
            BASE_SHA=${{ github.event.pull_request.base.sha }}
          else
            BASE_SHA="HEAD^"
          fi

          # Get list of added/modified files (exclude deleted)
          CHANGED_FILES=$(git diff --name-only --diff-filter=AM "$BASE_SHA" HEAD)

          if [ -z "$CHANGED_FILES" ]; then
            echo "No files changed"
            exit 0
          fi

          # Filter out whitelisted files
          FILTERED_FILES=$(echo "$CHANGED_FILES" | grep -v -E '^turbo/apps/(web|site)/public/(og-image\.png|assets/(cta-ellipse\.png|code_illustration\.svg))$' || true)

          if [ -z "$FILTERED_FILES" ]; then
            echo "All changed files are whitelisted"
            exit 0
          fi

          # Check file sizes
          ./scripts/check-file-size.sh $FILTERED_FILES

  # Lint jobs - split into 4 parallel jobs for faster CI
  lint-eslint:
    runs-on: ubuntu-latest
    # Skip for release-please commits (only version bumps and changelogs)
    if: "${{ github.event_name != 'push' || !startsWith(github.event.head_commit.message, 'chore: release') }}"
    container:
      image: ghcr.io/vm0-ai/vm0-toolchain:20260203
    steps:
      - uses: actions/checkout@v6
      - uses: ./.github/actions/toolchain-init
      - name: Build Core Package
        working-directory: turbo
        run: pnpm turbo run build --filter=@vm0/core
      - name: Lint
        working-directory: turbo
        run: pnpm lint

  lint-types:
    runs-on: ubuntu-latest
    container:
      image: ghcr.io/vm0-ai/vm0-toolchain:20260203
    steps:
      - uses: actions/checkout@v6
      - uses: ./.github/actions/toolchain-init
      - name: Build Core Package
        working-directory: turbo
        run: pnpm turbo run build --filter=@vm0/core
      - name: Type Check
        working-directory: turbo
        run: pnpm check-types

  lint-format:
    runs-on: ubuntu-latest
    container:
      image: ghcr.io/vm0-ai/vm0-toolchain:20260203
    steps:
      - uses: actions/checkout@v6
      - uses: ./.github/actions/toolchain-init
      - name: Prettier
        working-directory: turbo
        run: pnpm prettier --check .

  lint-knip:
    runs-on: ubuntu-latest
    container:
      image: ghcr.io/vm0-ai/vm0-toolchain:20260203
    steps:
      - uses: actions/checkout@v6
      - uses: ./.github/actions/toolchain-init
      - name: Build Core Package
        working-directory: turbo
        run: pnpm turbo run build --filter=@vm0/core
      - name: Knip
        working-directory: turbo
        run: pnpm knip

  # Test jobs - split into 4 parallel jobs by project
  test-web:
    runs-on: ubuntu-latest
    # Skip for release-please commits (only version bumps and changelogs)
    if: "${{ github.event_name != 'push' || !startsWith(github.event.head_commit.message, 'chore: release') }}"
    container:
      image: ghcr.io/vm0-ai/vm0-toolchain:20260203
    services:
      postgres:
        image: postgres:17-alpine
        options: >-
          --health-cmd pg_isready
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5
        env:
          POSTGRES_HOST_AUTH_METHOD: trust
    steps:
      - uses: actions/checkout@v6
      - uses: ./.github/actions/toolchain-init
      - name: Build Core Package
        working-directory: turbo
        run: pnpm turbo run build --filter=@vm0/core
      - name: Run Database Migrations
        working-directory: turbo
        env:
          DATABASE_URL: postgresql://postgres@postgres:5432/postgres
        run: pnpm --filter web db:migrate
      - name: Test Web
        working-directory: turbo
        env:
          DATABASE_URL: postgresql://postgres@postgres:5432/postgres
        run: pnpm vitest run --project=web

  test-cli:
    runs-on: ubuntu-latest
    container:
      image: ghcr.io/vm0-ai/vm0-toolchain:20260203
    steps:
      - uses: actions/checkout@v6
      - uses: ./.github/actions/toolchain-init
      - name: Build Core Package
        working-directory: turbo
        run: pnpm turbo run build --filter=@vm0/core
      - name: Test CLI
        working-directory: turbo
        run: pnpm vitest run --project=@vm0/cli

  test-platform:
    runs-on: ubuntu-latest
    container:
      image: ghcr.io/vm0-ai/vm0-toolchain:20260203
    steps:
      - uses: actions/checkout@v6
      - uses: ./.github/actions/toolchain-init
      - name: Build Core Package
        working-directory: turbo
        run: pnpm turbo run build --filter=@vm0/core
      - name: Test Platform
        working-directory: turbo
        run: pnpm vitest run --project=@vm0/platform

  test-other:
    runs-on: ubuntu-latest
    container:
      image: ghcr.io/vm0-ai/vm0-toolchain-rust:20260203
    steps:
      - uses: actions/checkout@v6
      - uses: ./.github/actions/toolchain-init
      - name: Build Core Package
        working-directory: turbo
        run: pnpm turbo run build --filter=@vm0/core
      - name: Build vsock-guest (for runner tests)
        run: cargo build --manifest-path crates/Cargo.toml -p vsock-guest
      - name: Test Other Packages
        working-directory: turbo
        run: pnpm vitest run --project=@vm0/runner --project=@vm0/core --project=@vm0/ui --project=site

  # Deploy web application with database
  deploy-web:
    runs-on: ubuntu-latest
    container:
      image: ghcr.io/vm0-ai/vm0-toolchain:20260203
    needs: [prepare]
    # Deploy if job-ref is set (PR or main), not a release-please commit, and web, CLI, runner, site, or platform changed
    if: |
      (github.event_name != 'push' || !startsWith(github.event.head_commit.message, 'chore: release')) &&
      needs.prepare.outputs.job-ref != '' && (
        needs.prepare.outputs.web-changed == 'true' ||
        needs.prepare.outputs.cli-changed == 'true' ||
        needs.prepare.outputs.runner-changed == 'true' ||
        needs.prepare.outputs.site-changed == 'true' ||
        needs.prepare.outputs.platform-changed == 'true'
      )
    outputs:
      preview-url: ${{ steps.alias.outputs.url || steps.deploy.outputs.url }}
    permissions:
      contents: read
      pull-requests: write
      deployments: write
    steps:
      - uses: actions/checkout@v6
      - uses: ./.github/actions/toolchain-init

      # Step 1: Create Neon database branch
      - name: Create Neon Branch and Run Migrations
        id: branch
        uses: ./.github/actions/neon-branch
        with:
          neon-api-key: ${{ secrets.NEON_API_KEY }}
          neon-project-id: ${{ vars.NEON_PROJECT_ID }}
          branch-name: "${{ needs.prepare.outputs.job-ref }}"
          action: "create"

      # Step 2: Deploy to Vercel with database URL
      - name: Deploy Web to Vercel
        id: deploy
        uses: ./.github/actions/vercel-deploy
        with:
          vercel-token: ${{ secrets.VERCEL_TOKEN }}
          vercel-org-id: ${{ vars.VERCEL_TEAM_ID }}
          vercel-project-id: ${{ vars.VERCEL_PROJECT_ID_WEB }}
          environment: preview
          deployment-env: web
          environment-variables: |
            DATABASE_URL=${{ steps.branch.outputs.database-url }}
            NEXT_PUBLIC_BASE_URL=${{ needs.prepare.outputs.web-preview-url }}
            NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY=${{ vars.CLERK_PUBLISHABLE_KEY }}
            CLERK_SECRET_KEY=${{ secrets.CLERK_SECRET_KEY }}
            E2B_API_KEY=${{ secrets.E2B_API_KEY }}
            R2_ACCOUNT_ID=${{ vars.R2_ACCOUNT_ID }}
            R2_ACCESS_KEY_ID=${{ secrets.R2_ACCESS_KEY_ID }}
            R2_SECRET_ACCESS_KEY=${{ secrets.R2_SECRET_ACCESS_KEY }}
            R2_USER_STORAGES_BUCKET_NAME=${{ vars.R2_USER_STORAGES_BUCKET_NAME }}
            SECRETS_ENCRYPTION_KEY=${{ secrets.SECRETS_ENCRYPTION_KEY }}
            OFFICIAL_RUNNER_SECRET=${{ secrets.OFFICIAL_RUNNER_SECRET }}
            AXIOM_TOKEN=${{ secrets.AXIOM_TOKEN }}
            AXIOM_DATASET_SUFFIX=dev
            USE_MOCK_CLAUDE=true
            CRON_SECRET=${{ secrets.CRON_SECRET }}
            ABLY_API_KEY=${{ secrets.ABLY_API_KEY }}
            CONCURRENT_RUN_LIMIT=0
            VM0_DEBUG=*
            CLAUDE_CODE_VERSION_URL=${{ vars.CLAUDE_CODE_VERSION_URL }}
            OPENROUTER_API_KEY=${{ secrets.OPENROUTER_API_KEY }}
            SLACK_CLIENT_ID=${{ vars.SLACK_CLIENT_ID }}
            SLACK_CLIENT_SECRET=${{ secrets.SLACK_CLIENT_SECRET }}
            SLACK_SIGNING_SECRET=${{ secrets.SLACK_SIGNING_SECRET }}
            SLACK_REDIRECT_BASE_URL=${{ needs.prepare.outputs.web-preview-url }}
            SENTRY_DSN=${{ secrets.SENTRY_DSN_WEB }}
            NEXT_PUBLIC_SENTRY_DSN=${{ secrets.SENTRY_DSN_WEB }}
            SENTRY_AUTH_TOKEN=${{ secrets.SENTRY_AUTH_TOKEN }}
            SENTRY_ORG=${{ vars.SENTRY_ORG }}
            SENTRY_PROJECT=${{ vars.SENTRY_PROJECT_WEB }}
            GH_OAUTH_CLIENT_ID=${{ vars.GH_OAUTH_CLIENT_ID }}
            GH_OAUTH_CLIENT_SECRET=${{ secrets.GH_OAUTH_CLIENT_SECRET }}
          meta-branch: ${{ github.head_ref || github.ref_name }}
          meta-pr: ${{ needs.prepare.outputs.job-ref }}
          skip-finish: ${{ github.event_name == 'pull_request' && vars.PREVIEW_DOMAIN != '' }}

      # Step 3: Create stable preview URL alias (when PREVIEW_DOMAIN is configured)
      - name: Create Vercel Alias
        id: alias
        if: vars.PREVIEW_DOMAIN != ''
        uses: ./.github/actions/vercel-alias
        with:
          vercel-token: ${{ secrets.VERCEL_TOKEN }}
          vercel-org-id: ${{ vars.VERCEL_TEAM_ID }}
          deployment-url: ${{ steps.deploy.outputs.url }}
          app-name: www
          job-ref: ${{ needs.prepare.outputs.job-ref }}
          preview-domain: ${{ vars.PREVIEW_DOMAIN }}
          deployment-id: ${{ steps.deploy.outputs.deployment-id }}
          deployment-env: ${{ steps.deploy.outputs.deployment-env }}

      # Step 4: Generate test token for E2E tests (runs in parallel with e2e-auth)
      - name: Generate E2E test token
        run: e2e/scripts/generate-test-token.sh
        env:
          VM0_API_URL: ${{ steps.alias.outputs.url || steps.deploy.outputs.url }}
          VERCEL_AUTOMATION_BYPASS_SECRET: ${{ secrets.VERCEL_AUTOMATION_BYPASS_SECRET }}

      - name: Save test token to cache
        uses: actions/cache/save@v5
        with:
          path: ~/.vm0
          key: e2e-token-${{ github.run_id }}-${{ github.run_attempt }}

  # Deploy docs application
  deploy-docs:
    runs-on: ubuntu-latest
    container:
      image: ghcr.io/vm0-ai/vm0-toolchain:20260203
    needs: [prepare]
    # Deploy if job-ref is set (PR or main), not a release-please commit, and docs changed
    if: "${{ (github.event_name != 'push' || !startsWith(github.event.head_commit.message, 'chore: release')) && needs.prepare.outputs.job-ref != '' && needs.prepare.outputs.docs-changed == 'true' }}"
    permissions:
      contents: read
      pull-requests: write
      deployments: write
    steps:
      - uses: actions/checkout@v6
      - uses: ./.github/actions/toolchain-init

      - name: Deploy Docs to Vercel
        id: deploy
        uses: ./.github/actions/vercel-deploy
        with:
          vercel-token: ${{ secrets.VERCEL_TOKEN }}
          vercel-org-id: ${{ vars.VERCEL_TEAM_ID }}
          vercel-project-id: ${{ vars.VERCEL_PROJECT_ID_DOCS }}
          environment: preview
          deployment-env: docs
          meta-branch: ${{ github.head_ref || github.ref_name }}
          meta-pr: ${{ needs.prepare.outputs.job-ref }}
          skip-finish: ${{ github.event_name == 'pull_request' && vars.PREVIEW_DOMAIN != '' }}

      - name: Create Vercel Alias
        if: vars.PREVIEW_DOMAIN != ''
        uses: ./.github/actions/vercel-alias
        with:
          vercel-token: ${{ secrets.VERCEL_TOKEN }}
          vercel-org-id: ${{ vars.VERCEL_TEAM_ID }}
          deployment-url: ${{ steps.deploy.outputs.url }}
          app-name: docs
          job-ref: ${{ needs.prepare.outputs.job-ref }}
          preview-domain: ${{ vars.PREVIEW_DOMAIN }}
          deployment-id: ${{ steps.deploy.outputs.deployment-id }}
          deployment-env: ${{ steps.deploy.outputs.deployment-env }}

  # Deploy site application (SEO landing pages)
  deploy-site:
    runs-on: ubuntu-latest
    container:
      image: ghcr.io/vm0-ai/vm0-toolchain:20260203
    needs: [prepare]
    # Deploy if job-ref is set (PR or main), not a release-please commit, and site changed
    if: "${{ (github.event_name != 'push' || !startsWith(github.event.head_commit.message, 'chore: release')) && needs.prepare.outputs.job-ref != '' && needs.prepare.outputs.site-changed == 'true' }}"
    permissions:
      contents: read
      pull-requests: write
      deployments: write
    steps:
      - uses: actions/checkout@v6
      - uses: ./.github/actions/toolchain-init

      - name: Deploy Site to Vercel
        id: deploy
        uses: ./.github/actions/vercel-deploy
        with:
          vercel-token: ${{ secrets.VERCEL_TOKEN }}
          vercel-org-id: ${{ vars.VERCEL_TEAM_ID }}
          vercel-project-id: ${{ vars.VERCEL_PROJECT_ID_SITE }}
          environment: preview
          deployment-env: site
          environment-variables: |
            WEB_APP_URL=${{ needs.prepare.outputs.web-preview-url }}
            NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY=${{ vars.CLERK_PUBLISHABLE_KEY }}
            CLERK_SECRET_KEY=${{ secrets.CLERK_SECRET_KEY }}
          meta-branch: ${{ github.head_ref || github.ref_name }}
          meta-pr: ${{ needs.prepare.outputs.job-ref }}
          skip-finish: ${{ github.event_name == 'pull_request' && vars.PREVIEW_DOMAIN != '' }}

      - name: Create Vercel Alias
        if: vars.PREVIEW_DOMAIN != ''
        uses: ./.github/actions/vercel-alias
        with:
          vercel-token: ${{ secrets.VERCEL_TOKEN }}
          vercel-org-id: ${{ vars.VERCEL_TEAM_ID }}
          deployment-url: ${{ steps.deploy.outputs.url }}
          app-name: site
          job-ref: ${{ needs.prepare.outputs.job-ref }}
          preview-domain: ${{ vars.PREVIEW_DOMAIN }}
          deployment-id: ${{ steps.deploy.outputs.deployment-id }}
          deployment-env: ${{ steps.deploy.outputs.deployment-env }}

  # Deploy platform (Vite SPA)
  deploy-platform:
    runs-on: ubuntu-latest
    container:
      image: ghcr.io/vm0-ai/vm0-toolchain:20260203
    needs: [prepare]
    # Deploy if job-ref is set (PR or main), not a release-please commit, and platform changed
    if: "${{ (github.event_name != 'push' || !startsWith(github.event.head_commit.message, 'chore: release')) && needs.prepare.outputs.job-ref != '' && needs.prepare.outputs.platform-changed == 'true' }}"
    permissions:
      contents: read
      pull-requests: write
      deployments: write
    steps:
      - uses: actions/checkout@v6
      - uses: ./.github/actions/toolchain-init

      - name: Deploy Platform to Vercel
        id: deploy
        uses: ./.github/actions/vercel-deploy
        with:
          vercel-token: ${{ secrets.VERCEL_TOKEN }}
          vercel-org-id: ${{ vars.VERCEL_TEAM_ID }}
          vercel-project-id: ${{ vars.VERCEL_PROJECT_ID_PLATFORM }}
          environment: preview
          deployment-env: platform
          environment-variables: |
            VITE_CLERK_PUBLISHABLE_KEY=${{ vars.CLERK_PUBLISHABLE_KEY }}
            VITE_API_URL=${{ needs.prepare.outputs.web-preview-url }}
            VITE_SENTRY_DSN=${{ secrets.SENTRY_DSN_PLATFORM }}
            SENTRY_AUTH_TOKEN=${{ secrets.SENTRY_AUTH_TOKEN }}
            SENTRY_ORG=${{ vars.SENTRY_ORG }}
            SENTRY_PROJECT=${{ vars.SENTRY_PROJECT_PLATFORM }}
          meta-branch: ${{ github.head_ref || github.ref_name }}
          meta-pr: ${{ needs.prepare.outputs.job-ref }}
          skip-finish: ${{ github.event_name == 'pull_request' && vars.PREVIEW_DOMAIN != '' }}

      - name: Create Vercel Alias
        if: vars.PREVIEW_DOMAIN != ''
        uses: ./.github/actions/vercel-alias
        with:
          vercel-token: ${{ secrets.VERCEL_TOKEN }}
          vercel-org-id: ${{ vars.VERCEL_TEAM_ID }}
          deployment-url: ${{ steps.deploy.outputs.url }}
          app-name: platform
          job-ref: ${{ needs.prepare.outputs.job-ref }}
          preview-domain: ${{ vars.PREVIEW_DOMAIN }}
          deployment-id: ${{ steps.deploy.outputs.deployment-id }}
          deployment-env: ${{ steps.deploy.outputs.deployment-env }}

  # Verify device flow authentication works end-to-end (uses Playwright)
  # This job runs in parallel with E2E tests - it does NOT block them
  # E2E tests use the token generated by deploy-web instead
  e2e-auth:
    runs-on: ubuntu-latest
    container:
      image: ghcr.io/vm0-ai/vm0-toolchain:20260203
    needs: [prepare, deploy-web]
    if: |
      (github.event_name != 'push' || !startsWith(github.event.head_commit.message, 'chore: release')) &&
      needs.prepare.outputs.job-ref != '' && (
        needs.prepare.outputs.web-changed == 'true' ||
        needs.prepare.outputs.cli-changed == 'true' ||
        needs.prepare.outputs.runner-changed == 'true'
      )
    steps:
      - uses: actions/checkout@v6
        with:
          submodules: recursive
      - uses: ./.github/actions/toolchain-init

      - name: Setup pnpm global directory
        run: |
          mkdir -p $HOME/.local/share/pnpm
          pnpm config set global-bin-dir $HOME/.local/share/pnpm
          echo "$HOME/.local/share/pnpm" >> $GITHUB_PATH

      - name: Build Core Package
        run: cd turbo && pnpm turbo run build --filter=@vm0/core

      - name: Build CLI
        run: cd turbo && pnpm --filter @vm0/cli build

      - name: Setup CLI globally
        run: cd turbo/apps/cli && pnpm link --global

      - name: Install E2E dependencies
        run: cd e2e && npm install

      - name: Install Playwright system dependencies
        run: npx playwright install-deps chromium

      - name: Install Playwright browsers
        run: cd e2e && npx playwright install chromium

      - name: Verify device flow authentication
        run: |
          echo "Verifying device flow with ${{ needs.deploy-web.outputs.preview-url }}"
          cd e2e && npm run auth
        env:
          VM0_API_URL: ${{ needs.deploy-web.outputs.preview-url }}
          CLERK_PUBLISHABLE_KEY: ${{ vars.CLERK_PUBLISHABLE_KEY }}
          CLERK_SECRET_KEY: ${{ secrets.CLERK_SECRET_KEY }}
          VERCEL_AUTOMATION_BYPASS_SECRET: ${{ secrets.VERCEL_AUTOMATION_BYPASS_SECRET }}

  # Run API E2E tests (lightweight, fast)
  api-e2e-test:
    runs-on: ubuntu-latest
    container:
      image: ghcr.io/vm0-ai/vm0-toolchain:20260203
    needs: [prepare, deploy-web]
    if: "${{ (github.event_name != 'push' || !startsWith(github.event.head_commit.message, 'chore: release')) && needs.prepare.outputs.job-ref != '' && needs.prepare.outputs.web-changed == 'true' }}"
    timeout-minutes: 5
    permissions:
      actions: read # Required to query cache API
    steps:
      - uses: actions/checkout@v6
        with:
          submodules: recursive # For BATS test framework

      - name: Restore test token from cache
        uses: actions/cache/restore@v5
        with:
          path: ~/.vm0
          key: e2e-token-${{ github.run_id }}-${{ github.run_attempt }}
          restore-keys: |
            e2e-token-${{ github.run_id }}-
          fail-on-cache-miss: true

      - name: Run API E2E Tests
        run: |
          echo "=== Running API E2E Tests ==="
          ./e2e/test/libs/bats/bin/bats -T ./e2e/tests/api/*.bats
        env:
          VM0_API_URL: ${{ needs.deploy-web.outputs.preview-url }}
          VERCEL_AUTOMATION_BYPASS_SECRET: ${{ secrets.VERCEL_AUTOMATION_BYPASS_SECRET }}

  # Run CLI E2E tests - Phase 1: Serial tests (establishes e2e-stable scope)
  cli-e2e-01-serial:
    runs-on: ubuntu-latest
    container:
      image: ghcr.io/vm0-ai/vm0-toolchain:20260203
    needs:
      [
        prepare,
        deploy-web,
        lint-eslint,
        lint-types,
        lint-format,
        lint-knip,
        test-web,
        test-cli,
        test-platform,
        test-other,
      ]
    if: |
      (github.event_name != 'push' || !startsWith(github.event.head_commit.message, 'chore: release')) &&
      needs.prepare.outputs.job-ref != '' && (
        needs.prepare.outputs.web-changed == 'true' ||
        needs.prepare.outputs.cli-changed == 'true' ||
        needs.prepare.outputs.runner-changed == 'true'
      )
    timeout-minutes: 5
    permissions:
      actions: read # Required to query cache API
    steps:
      - uses: actions/checkout@v6
        with:
          submodules: recursive
      - uses: ./.github/actions/toolchain-init

      - name: Setup pnpm global directory
        run: |
          mkdir -p $HOME/.local/share/pnpm
          pnpm config set global-bin-dir $HOME/.local/share/pnpm
          echo "$HOME/.local/share/pnpm" >> $GITHUB_PATH

      - name: Build Core Package
        run: cd turbo && pnpm turbo run build --filter=@vm0/core

      - name: Build CLI
        run: cd turbo && pnpm --filter @vm0/cli build

      - name: Setup CLI globally
        run: cd turbo/apps/cli && pnpm link --global

      - name: Restore test token from cache
        uses: actions/cache/restore@v5
        with:
          path: ~/.vm0
          key: e2e-token-${{ github.run_id }}-${{ github.run_attempt }}
          restore-keys: |
            e2e-token-${{ github.run_id }}-
          fail-on-cache-miss: true

      - name: Start Cron Simulator
        run: |
          chmod +x ./e2e/scripts/cron-simulator.sh
          ./e2e/scripts/cron-simulator.sh "$VM0_API_URL" 60 &
          echo "CRON_SIMULATOR_PID=$!" >> $GITHUB_ENV
        env:
          VM0_API_URL: ${{ needs.deploy-web.outputs.preview-url }}
          CRON_SECRET: ${{ secrets.CRON_SECRET }}
          VERCEL_AUTOMATION_BYPASS_SECRET: ${{ secrets.VERCEL_AUTOMATION_BYPASS_SECRET }}

      - name: Run Serial E2E Tests
        run: |
          echo "=== Running Serial E2E Tests ==="
          BATS_TEST_TIMEOUT=30 ./e2e/test/libs/bats/bin/bats -T ./e2e/tests/01-serial/*.bats
          echo "✅ Serial tests passed"
        env:
          VM0_API_URL: ${{ needs.deploy-web.outputs.preview-url }}
          VERCEL_AUTOMATION_BYPASS_SECRET: ${{ secrets.VERCEL_AUTOMATION_BYPASS_SECRET }}
          USE_MOCK_CLAUDE: "true"

      - name: Stop Cron Simulator
        if: always()
        run: |
          if [ -n "$CRON_SIMULATOR_PID" ]; then
            kill "$CRON_SIMULATOR_PID" 2>/dev/null || true
            echo "Cron simulator stopped"
          fi

  # Run CLI E2E tests - Phase 2: Parallel tests (does NOT need runner)
  # Uses dynamic matrix to split test files into chunks for parallel execution
  cli-e2e-02-parallel:
    runs-on: ubuntu-latest
    container:
      image: ghcr.io/vm0-ai/vm0-toolchain:20260203
    needs: [prepare, cli-e2e-01-serial, deploy-web]
    if: |
      (github.event_name != 'push' || !startsWith(github.event.head_commit.message, 'chore: release')) &&
      needs.prepare.outputs.job-ref != '' && (
        needs.prepare.outputs.web-changed == 'true' ||
        needs.prepare.outputs.cli-changed == 'true' ||
        needs.prepare.outputs.runner-changed == 'true'
      )
    strategy:
      fail-fast: false
      matrix:
        include: ${{ fromJSON(needs.prepare.outputs.cli-e2e-parallel-matrix) }}
    timeout-minutes: 5
    steps:
      - uses: actions/checkout@v6
        with:
          submodules: recursive
      - uses: ./.github/actions/toolchain-init

      - name: Setup pnpm global directory
        run: |
          mkdir -p $HOME/.local/share/pnpm
          pnpm config set global-bin-dir $HOME/.local/share/pnpm
          echo "$HOME/.local/share/pnpm" >> $GITHUB_PATH

      - name: Build Core Package
        run: cd turbo && pnpm turbo run build --filter=@vm0/core

      - name: Build CLI
        run: cd turbo && pnpm --filter @vm0/cli build

      - name: Setup CLI globally
        run: cd turbo/apps/cli && pnpm link --global

      - name: Install GNU parallel for bats
        run: apt-get update && apt-get install -y parallel

      - name: Restore test token from cache
        uses: actions/cache/restore@v5
        with:
          path: ~/.vm0
          key: e2e-token-${{ github.run_id }}-${{ github.run_attempt }}
          restore-keys: |
            e2e-token-${{ github.run_id }}-
          fail-on-cache-miss: true

      - name: Start Cron Simulator
        run: |
          chmod +x ./e2e/scripts/cron-simulator.sh
          ./e2e/scripts/cron-simulator.sh "$VM0_API_URL" 60 &
          echo "CRON_SIMULATOR_PID=$!" >> $GITHUB_ENV
        env:
          VM0_API_URL: ${{ needs.deploy-web.outputs.preview-url }}
          CRON_SECRET: ${{ secrets.CRON_SECRET }}
          VERCEL_AUTOMATION_BYPASS_SECRET: ${{ secrets.VERCEL_AUTOMATION_BYPASS_SECRET }}

      - name: Run Parallel E2E Tests (Chunk ${{ matrix.index }})
        run: |
          echo "=== Running Parallel E2E Tests (Chunk ${{ matrix.index }}) ==="
          echo "Files: ${{ matrix.files }}"
          BATS_TEST_TIMEOUT=60 ./e2e/test/libs/bats/bin/bats -T -j 5 --no-parallelize-within-files ${{ matrix.files }}
          echo "✅ Chunk ${{ matrix.index }} tests passed"
        env:
          VM0_API_URL: ${{ needs.deploy-web.outputs.preview-url }}
          VERCEL_AUTOMATION_BYPASS_SECRET: ${{ secrets.VERCEL_AUTOMATION_BYPASS_SECRET }}
          USE_MOCK_CLAUDE: "true"
          ANTHROPIC_API_KEY: ${{ secrets.ANTHROPIC_API_KEY }}

      - name: Stop Cron Simulator
        if: always()
        run: |
          if [ -n "$CRON_SIMULATOR_PID" ]; then
            kill "$CRON_SIMULATOR_PID" 2>/dev/null || true
            echo "Cron simulator stopped"
          fi

  # Run CLI E2E tests - Phase 3: Runner tests (needs runner deployed)
  # Skip on push to main - runner tests are only needed for PRs
  cli-e2e-03-runner:
    runs-on: ubuntu-latest
    container:
      image: ghcr.io/vm0-ai/vm0-toolchain:20260203
    needs:
      [
        prepare,
        cli-e2e-01-serial,
        deploy-web,
        deploy-runner-start,
        deploy-runner-benchmark,
      ]
    if: |
      contains(github.event.pull_request.labels.*.name, 'needs-runner-pipeline') &&
      github.event_name != 'push' &&
      needs.prepare.outputs.job-ref != '' && (
        needs.prepare.outputs.web-changed == 'true' ||
        needs.prepare.outputs.cli-changed == 'true' ||
        needs.prepare.outputs.runner-changed == 'true'
      )
    timeout-minutes: 8
    steps:
      - uses: actions/checkout@v6
        with:
          submodules: recursive
      - uses: ./.github/actions/toolchain-init

      - name: Setup pnpm global directory
        run: |
          mkdir -p $HOME/.local/share/pnpm
          pnpm config set global-bin-dir $HOME/.local/share/pnpm
          echo "$HOME/.local/share/pnpm" >> $GITHUB_PATH

      - name: Build Core Package
        run: cd turbo && pnpm turbo run build --filter=@vm0/core

      - name: Build CLI
        run: cd turbo && pnpm --filter @vm0/cli build

      - name: Setup CLI globally
        run: cd turbo/apps/cli && pnpm link --global

      - name: Install GNU parallel for bats
        run: apt-get update && apt-get install -y parallel

      - name: Restore test token from cache
        uses: actions/cache/restore@v5
        with:
          path: ~/.vm0
          key: e2e-token-${{ github.run_id }}-${{ github.run_attempt }}
          restore-keys: |
            e2e-token-${{ github.run_id }}-
          fail-on-cache-miss: true

      - name: Start Cron Simulator
        run: |
          chmod +x ./e2e/scripts/cron-simulator.sh
          ./e2e/scripts/cron-simulator.sh "$VM0_API_URL" 60 &
          echo "CRON_SIMULATOR_PID=$!" >> $GITHUB_ENV
        env:
          VM0_API_URL: ${{ needs.deploy-web.outputs.preview-url }}
          CRON_SECRET: ${{ secrets.CRON_SECRET }}
          VERCEL_AUTOMATION_BYPASS_SECRET: ${{ secrets.VERCEL_AUTOMATION_BYPASS_SECRET }}

      - name: Run Runner E2E Tests
        run: |
          echo "=== Running Runner E2E Tests (4 parallel) ==="
          BATS_TEST_TIMEOUT=60 RUNNER_GROUP="vm0/development-${JOB_REF}" ./e2e/test/libs/bats/bin/bats -T -j 4 --no-parallelize-within-files ./e2e/tests/03-experimental-runner/*.bats
          echo "✅ Runner tests passed"
        env:
          VM0_API_URL: ${{ needs.deploy-web.outputs.preview-url }}
          VERCEL_AUTOMATION_BYPASS_SECRET: ${{ secrets.VERCEL_AUTOMATION_BYPASS_SECRET }}
          USE_MOCK_CLAUDE: "true"
          JOB_REF: ${{ needs.prepare.outputs.job-ref }}
          OFFICIAL_RUNNER_SECRET: ${{ secrets.OFFICIAL_RUNNER_SECRET }}

      - name: Stop Cron Simulator
        if: always()
        run: |
          if [ -n "$CRON_SIMULATOR_PID" ]; then
            kill "$CRON_SIMULATOR_PID" 2>/dev/null || true
            echo "Cron simulator stopped"
          fi

  # Prepare runner: lock host, build bundle, install deps (runs parallel with deploy-web)
  # Skip on push to main - runner deployment is only needed for PRs
  deploy-runner-prepare:
    runs-on: ubuntu-latest
    container:
      image: ghcr.io/vm0-ai/vm0-toolchain-rust:20260203
    needs: [prepare]
    if: |
      contains(github.event.pull_request.labels.*.name, 'needs-runner-pipeline') &&
      github.event_name != 'push' &&
      needs.prepare.outputs.job-ref != '' && (
        needs.prepare.outputs.web-changed == 'true' ||
        needs.prepare.outputs.cli-changed == 'true' ||
        needs.prepare.outputs.runner-changed == 'true'
      )
    outputs:
      runner-host: ${{ steps.lock.outputs.host }}
      runner-dir: ${{ steps.prepare.outputs.runner-dir }}
      proxy-port: ${{ steps.prepare.outputs.proxy-port }}
    steps:
      - uses: actions/checkout@v6
      - uses: ./.github/actions/toolchain-init

      - name: Lock runner host
        id: lock
        shell: bash
        env:
          JOB_REF: ${{ needs.prepare.outputs.job-ref }}
          METAL_HOSTS: ${{ secrets.AWS_METAL_RUNNER_HOSTS }}
          METAL_USER: ${{ vars.AWS_METAL_RUNNER_USER }}
          SSH_KEY: ${{ secrets.AWS_METAL_RUNNER_SSH_KEY }}
        run: |
          # Parse hosts into array
          IFS=',' read -ra HOSTS <<< "$METAL_HOSTS"
          NUM_HOSTS=${#HOSTS[@]}
          echo "Found $NUM_HOSTS runner hosts"

          # Setup SSH (use $HOME instead of ~ for proper expansion in container)
          SSH_DIR="$HOME/.ssh"
          SSH_KEY_FILE="$SSH_DIR/runner.pem"
          mkdir -p "$SSH_DIR"
          if [ -z "$SSH_KEY" ]; then
            echo "ERROR: SSH_KEY secret is empty!"
            exit 1
          fi
          echo "$SSH_KEY" > "$SSH_KEY_FILE"
          chmod 600 "$SSH_KEY_FILE"
          echo "SSH key file created at $SSH_KEY_FILE ($(wc -c < "$SSH_KEY_FILE") bytes)"

          SSH_OPTS="-o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null -o ConnectTimeout=10 -i $SSH_KEY_FILE"

          # Function to check if host is available (lock doesn't exist or is stale)
          check_and_acquire() {
            local host=$1

            echo "  Checking lock state on $host..."
            ssh $SSH_OPTS ${METAL_USER}@${host} "ls -la /opt/vm0-runner/.lock 2>&1 || echo '  (no lock directory)'" 2>/dev/null || echo "  (SSH failed)"

            # Check if lock directory exists
            lock_exists=$(ssh $SSH_OPTS ${METAL_USER}@${host} "test -d /opt/vm0-runner/.lock && echo 'yes'" 2>/dev/null || echo "")

            if [ "$lock_exists" = "yes" ]; then
              lock_time=$(ssh $SSH_OPTS ${METAL_USER}@${host} "cat /opt/vm0-runner/.lock/timestamp 2>/dev/null" || echo "")
              lock_ref=$(ssh $SSH_OPTS ${METAL_USER}@${host} "cat /opt/vm0-runner/.lock/ref 2>/dev/null" || echo "unknown")

              if [ -n "$lock_time" ]; then
                now=$(date +%s)
                age=$((now - lock_time))
                if [ $age -gt 1800 ]; then
                  echo "  Stale lock found ($lock_ref, ${age}s old), removing..."
                  ssh $SSH_OPTS ${METAL_USER}@${host} "rm -rf /opt/vm0-runner/.lock" 2>/dev/null || true
                else
                  echo "  Host is locked by $lock_ref (lock age: ${age}s)"
                  return 1
                fi
              else
                echo "  Lock directory exists but no timestamp (corrupt lock?), removing..."
                ssh $SSH_OPTS ${METAL_USER}@${host} "rm -rf /opt/vm0-runner/.lock" 2>/dev/null || true
              fi
            else
              echo "  No existing lock found"
            fi

            # Ensure parent directory exists and try atomic mkdir to acquire lock
            echo "  Attempting to create lock..."
            if ! ssh $SSH_OPTS ${METAL_USER}@${host} "test -d /opt/vm0-runner" 2>/dev/null; then
              echo "  Creating /opt/vm0-runner directory..."
              ssh $SSH_OPTS ${METAL_USER}@${host} "sudo mkdir -p /opt/vm0-runner && sudo chown ${METAL_USER}:${METAL_USER} /opt/vm0-runner" 2>&1 || {
                echo "  ERROR: Failed to create /opt/vm0-runner directory"
                return 1
              }
            fi
            mkdir_result=$(ssh $SSH_OPTS ${METAL_USER}@${host} "mkdir /opt/vm0-runner/.lock 2>&1 && echo 'SUCCESS'" || echo "FAILED")
            if [ "$mkdir_result" = "SUCCESS" ]; then
              ssh $SSH_OPTS ${METAL_USER}@${host} "echo ${JOB_REF} > /opt/vm0-runner/.lock/ref && date +%s > /opt/vm0-runner/.lock/timestamp"
              echo "  Lock acquired!"
              return 0
            else
              echo "  mkdir failed: $mkdir_result"
              return 1
            fi
          }

          # Preferred host based on job-ref (use hash for even distribution)
          HASH=$(echo -n "$JOB_REF" | md5sum | cut -c1-8)
          PREFERRED_INDEX=$((16#$HASH % NUM_HOSTS))
          echo "Preferred host index: $PREFERRED_INDEX (hash of $JOB_REF % $NUM_HOSTS)"

          # Exponential backoff: 0, 2min, 4min, 8min
          BACKOFF_TIMES=(0 120 240 480)

          for attempt in 0 1 2 3; do
            if [ $attempt -gt 0 ]; then
              wait_time=${BACKOFF_TIMES[$attempt]}
              echo ""
              echo "All hosts busy. Waiting ${wait_time} seconds before retry (attempt $((attempt+1))/4)..."
              sleep $wait_time
            fi

            echo ""
            echo "=== Attempt $((attempt+1))/4 ==="

            # Try preferred host first
            host=${HOSTS[$PREFERRED_INDEX]}
            echo "Trying preferred host: $host"
            if check_and_acquire "$host"; then
              echo "host=$host" >> $GITHUB_OUTPUT
              echo ""
              echo "SUCCESS: Acquired lock on $host"
              exit 0
            fi

            # Try other hosts in order
            for i in $(seq 0 $((NUM_HOSTS-1))); do
              if [ $i -eq $PREFERRED_INDEX ]; then
                continue
              fi
              host=${HOSTS[$i]}
              echo "Trying fallback host: $host"
              if check_and_acquire "$host"; then
                echo "host=$host" >> $GITHUB_OUTPUT
                echo ""
                echo "SUCCESS: Acquired lock on $host"
                exit 0
              fi
            done
          done

          echo ""
          echo "ERROR: Could not acquire lock on any host after 4 attempts (~14 minutes)"
          echo "All runner hosts are busy. Please try again later or check for stale locks."
          exit 1

      - name: Build Core Package
        run: cd turbo && pnpm turbo run build --filter=@vm0/core

      # Cross-compile Rust binaries for ARM64 (metal runners are ARM64)
      - name: Build guest-init and guest-download for ARM64
        run: |
          cd crates
          CARGO_TARGET_AARCH64_UNKNOWN_LINUX_MUSL_LINKER=aarch64-linux-gnu-gcc \
            cargo build --release --target aarch64-unknown-linux-musl -p guest-init -p guest-download
          ls -la target/aarch64-unknown-linux-musl/release/guest-init
          ls -la target/aarch64-unknown-linux-musl/release/guest-download

      - name: Build runner bundle
        run: |
          cd turbo && pnpm --filter @vm0/runner build
          cd ..

          STAGING_DIR="/tmp/vm0-runner-bundle"
          rm -rf "$STAGING_DIR"
          mkdir -p "$STAGING_DIR"
          cp -r turbo/apps/runner/dist/* "$STAGING_DIR/"

          cd "$STAGING_DIR" && npm install --omit=dev
          cd -

          tar -czf /tmp/vm0-runner-bundle.tar.gz -C /tmp vm0-runner-bundle
          echo "Bundle created: $(ls -lh /tmp/vm0-runner-bundle.tar.gz)"

      - name: Install Python3 and Ansible
        run: |
          apt-get update && apt-get install -y python3 python3-pip
          pip3 install ansible

      - name: Prepare runner (deploy bundle, install deps)
        id: prepare
        env:
          JOB_REF: ${{ needs.prepare.outputs.job-ref }}
          METAL_USER: ${{ vars.AWS_METAL_RUNNER_USER }}
          RUNNER_HOST: ${{ steps.lock.outputs.host }}
          SSH_KEY: ${{ secrets.AWS_METAL_RUNNER_SSH_KEY }}
        run: |
          RUNNER_DIR="/opt/vm0-runner/${JOB_REF}"
          # Use numeric hash of job-ref for proxy port to ensure consistency
          PROXY_PORT=$(echo -n "${JOB_REF}" | md5sum | cut -c1-8 | sed 's/[a-f]//g' | cut -c1-3 | awk '{print 8080 + int($1)}')

          mkdir -p "$HOME/.ssh"
          echo "$SSH_KEY" > "$HOME/.ssh/runner.pem"
          chmod 600 "$HOME/.ssh/runner.pem"

          echo "Preparing runner on host: ${RUNNER_HOST}"

          cd ansible
          ansible-playbook \
            -i "${RUNNER_HOST}," \
            playbooks/deploy-runner.yml \
            --tags prepare \
            --private-key "$HOME/.ssh/runner.pem" \
            -e "ansible_user=${METAL_USER}" \
            -e "runner_base_dir=${RUNNER_DIR}" \
            -e "pm2_process_name=vm0-runner-${JOB_REF}" \
            -e "runner_bundle_path=/tmp/vm0-runner-bundle.tar.gz" \
            -e "rootfs_path=${RUNNER_DIR}/rootfs.squashfs" \
            -e "snapshot_path=${RUNNER_DIR}/snapshot" \
            -e "force_rebuild_rootfs=true" \
            -e "proxy_port=${PROXY_PORT}" \
            -e '{"enable_drain": true, "drain_timeout": 300}' \
            -v

          echo "runner-dir=${RUNNER_DIR}" >> $GITHUB_OUTPUT
          echo "proxy-port=${PROXY_PORT}" >> $GITHUB_OUTPUT
          echo "Runner prepared at ${RUNNER_DIR} on ${RUNNER_HOST}"

  # Run benchmark command to test VM boot performance (runs after start)
  # Skip on push to main - runner benchmark is only needed for PRs
  deploy-runner-benchmark:
    runs-on: ubuntu-latest
    container:
      image: ghcr.io/vm0-ai/vm0-toolchain:20260203
    needs: [prepare, deploy-runner-prepare, deploy-runner-start]
    if: |
      contains(github.event.pull_request.labels.*.name, 'needs-runner-pipeline') &&
      github.event_name != 'push' &&
      needs.prepare.outputs.job-ref != '' && (
        needs.prepare.outputs.web-changed == 'true' ||
        needs.prepare.outputs.cli-changed == 'true' ||
        needs.prepare.outputs.runner-changed == 'true'
      )
    steps:
      - uses: actions/checkout@v6

      - name: Run benchmark command for VM performance testing
        env:
          METAL_USER: ${{ vars.AWS_METAL_RUNNER_USER }}
          RUNNER_HOST: ${{ needs.deploy-runner-prepare.outputs.runner-host }}
          RUNNER_DIR: ${{ needs.deploy-runner-prepare.outputs.runner-dir }}
          PROXY_PORT: ${{ needs.deploy-runner-prepare.outputs.proxy-port }}
          SSH_KEY: ${{ secrets.AWS_METAL_RUNNER_SSH_KEY }}
        run: |
          mkdir -p "$HOME/.ssh"
          echo "$SSH_KEY" > "$HOME/.ssh/runner.pem"
          chmod 600 "$HOME/.ssh/runner.pem"

          SSH_OPTS="-o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null -o ConnectTimeout=10 -i $HOME/.ssh/runner.pem"

          echo "=== Running VM Benchmark on ${RUNNER_HOST} ==="
          echo "Runner directory: ${RUNNER_DIR}"
          echo "Proxy port: ${PROXY_PORT}"
          echo ""

          # Create benchmark config with proxy settings and snapshot (firewall + mitm enabled by default)
          ssh $SSH_OPTS ${METAL_USER}@${RUNNER_HOST} "
            echo 'base_dir: ${RUNNER_DIR}/benchmark' > ${RUNNER_DIR}/benchmark.yaml
            echo 'firecracker:' >> ${RUNNER_DIR}/benchmark.yaml
            echo '  binary: /usr/local/bin/firecracker' >> ${RUNNER_DIR}/benchmark.yaml
            echo '  kernel: /opt/firecracker/vmlinux' >> ${RUNNER_DIR}/benchmark.yaml
            echo '  rootfs: ${RUNNER_DIR}/rootfs.squashfs' >> ${RUNNER_DIR}/benchmark.yaml
            echo '  snapshot:' >> ${RUNNER_DIR}/benchmark.yaml
            echo '    snapshot: ${RUNNER_DIR}/snapshot/snapshot.bin' >> ${RUNNER_DIR}/benchmark.yaml
            echo '    memory: ${RUNNER_DIR}/snapshot/memory.bin' >> ${RUNNER_DIR}/benchmark.yaml
            echo '    overlay: ${RUNNER_DIR}/snapshot/overlay.ext4' >> ${RUNNER_DIR}/benchmark.yaml
            echo 'proxy:' >> ${RUNNER_DIR}/benchmark.yaml
            echo '  port: ${PROXY_PORT}' >> ${RUNNER_DIR}/benchmark.yaml
            echo '  ca_dir: ${RUNNER_DIR}/proxy' >> ${RUNNER_DIR}/benchmark.yaml
          "

          # Run benchmark command with curl test to verify HTTPS through proxy
          ssh $SSH_OPTS ${METAL_USER}@${RUNNER_HOST} "cd ${RUNNER_DIR} && node index.js benchmark --config benchmark.yaml 'curl -s https://httpbin.org/get | head -5'" 2>&1 || {
            echo "Benchmark command failed (exit code: $?)"
            echo "This may indicate issues with VM boot, proxy, or Firecracker setup"
            exit 1
          }

          echo ""
          echo "=== VM Benchmark Complete ==="

  # Start runner after deploy-web provides preview URL
  # Skip on push to main - runner deployment is only needed for PRs
  deploy-runner-start:
    runs-on: ubuntu-latest
    container:
      image: ghcr.io/vm0-ai/vm0-toolchain:20260203
    needs: [prepare, deploy-web, deploy-runner-prepare]
    if: |
      contains(github.event.pull_request.labels.*.name, 'needs-runner-pipeline') &&
      github.event_name != 'push' &&
      needs.prepare.outputs.job-ref != '' && (
        needs.prepare.outputs.web-changed == 'true' ||
        needs.prepare.outputs.cli-changed == 'true' ||
        needs.prepare.outputs.runner-changed == 'true'
      )
    outputs:
      runner-deployed: ${{ steps.start.outputs.runner-deployed }}
      runner-dir: ${{ needs.deploy-runner-prepare.outputs.runner-dir }}
      runner-host: ${{ needs.deploy-runner-prepare.outputs.runner-host }}
    steps:
      - uses: actions/checkout@v6
      - uses: ./.github/actions/toolchain-init

      - name: Install Python3 and Ansible
        run: |
          apt-get update && apt-get install -y python3 python3-pip
          pip3 install ansible

      - name: Start runner (configure and launch)
        id: start
        env:
          JOB_REF: ${{ needs.prepare.outputs.job-ref }}
          METAL_USER: ${{ vars.AWS_METAL_RUNNER_USER }}
          RUNNER_HOST: ${{ needs.deploy-runner-prepare.outputs.runner-host }}
          RUNNER_DIR: ${{ needs.deploy-runner-prepare.outputs.runner-dir }}
          PROXY_PORT: ${{ needs.deploy-runner-prepare.outputs.proxy-port }}
          SSH_KEY: ${{ secrets.AWS_METAL_RUNNER_SSH_KEY }}
          OFFICIAL_RUNNER_SECRET: ${{ secrets.OFFICIAL_RUNNER_SECRET }}
          PREVIEW_URL: ${{ needs.deploy-web.outputs.preview-url }}
          VERCEL_BYPASS: ${{ secrets.VERCEL_AUTOMATION_BYPASS_SECRET }}
        run: |
          mkdir -p "$HOME/.ssh"
          echo "$SSH_KEY" > "$HOME/.ssh/runner.pem"
          chmod 600 "$HOME/.ssh/runner.pem"

          echo "Starting runner on host: ${RUNNER_HOST}"

          cd ansible
          ansible-playbook \
            -i "${RUNNER_HOST}," \
            playbooks/deploy-runner.yml \
            --tags start \
            --private-key "$HOME/.ssh/runner.pem" \
            -e "ansible_user=${METAL_USER}" \
            -e "runner_base_dir=${RUNNER_DIR}" \
            -e "runner_group=vm0/development-${JOB_REF}" \
            -e "runner_suffix=${JOB_REF}" \
            -e "pm2_process_name=vm0-runner-${JOB_REF}" \
            -e "official_runner_secret=${OFFICIAL_RUNNER_SECRET}" \
            -e "api_url=${PREVIEW_URL}" \
            -e "rootfs_path=${RUNNER_DIR}/rootfs.squashfs" \
            -e "snapshot_path=${RUNNER_DIR}/snapshot" \
            -e "proxy_port=${PROXY_PORT}" \
            -e '{"extra_env": {"VERCEL_AUTOMATION_BYPASS_SECRET": "'"${VERCEL_BYPASS}"'", "USE_MOCK_CLAUDE": "true"}}' \
            -v

          echo "runner-deployed=true" >> $GITHUB_OUTPUT
          echo "Runner started at ${RUNNER_DIR} on ${RUNNER_HOST}"

  # Stop runner and release host lock after cli-e2e-03-runner completes (or fails/times out)
  # Runner must be stopped to prevent stale runners from claiming jobs in subsequent CI runs
  # Skip on push to main - runner deployment is only needed for PRs
  unlock-runner-host:
    runs-on: ubuntu-latest
    needs: [deploy-runner-prepare, cli-e2e-03-runner]
    if: always() && contains(github.event.pull_request.labels.*.name, 'needs-runner-pipeline') && github.event_name != 'push' && needs.deploy-runner-prepare.outputs.runner-host != ''
    steps:
      - name: Stop runner and unlock host
        env:
          RUNNER_HOST: ${{ needs.deploy-runner-prepare.outputs.runner-host }}
          RUNNER_DIR: ${{ needs.deploy-runner-prepare.outputs.runner-dir }}
          METAL_USER: ${{ vars.AWS_METAL_RUNNER_USER }}
          SSH_KEY: ${{ secrets.AWS_METAL_RUNNER_SSH_KEY }}
        run: |
          mkdir -p "$HOME/.ssh"
          echo "$SSH_KEY" > "$HOME/.ssh/runner.pem"
          chmod 600 "$HOME/.ssh/runner.pem"
          SSH_OPTS="-o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null -o ConnectTimeout=10 -i $HOME/.ssh/runner.pem"

          # Extract job ref from runner dir (e.g., /opt/vm0-runner/pr-1900 -> pr-1900)
          JOB_REF=$(basename "$RUNNER_DIR")
          if [ -n "$JOB_REF" ]; then
            PM2_NAME="vm0-runner-${JOB_REF}"
            echo "Stopping runner ${PM2_NAME} gracefully..."
            # Use pm2 stop first to send SIGTERM and allow cleanup (TAP/IP release)
            # --kill-timeout gives the process 10s to cleanup before SIGKILL
            ssh $SSH_OPTS ${METAL_USER}@${RUNNER_HOST} "pm2 stop ${PM2_NAME} --kill-timeout 10000 2>/dev/null || true"
            # Wait for process to fully exit (pm2 stop is async)
            # pm2 pid returns 0 when process is stopped, empty when deleted
            echo "Waiting for runner to exit..."
            for i in $(seq 1 15); do
              pid=$(ssh $SSH_OPTS ${METAL_USER}@${RUNNER_HOST} "pm2 pid ${PM2_NAME} 2>/dev/null" || true)
              if [ -z "$pid" ] || [ "$pid" = "0" ]; then
                echo "Runner exited"
                break
              fi
              echo "  Still running (pid: $pid), waiting..."
              sleep 1
            done
            # Remove from pm2 process list
            ssh $SSH_OPTS ${METAL_USER}@${RUNNER_HOST} "pm2 delete ${PM2_NAME} 2>/dev/null || true"
            echo "Runner stopped and removed from pm2"
          fi

          # Release the host lock
          ssh $SSH_OPTS ${METAL_USER}@${RUNNER_HOST} "rm -rf /opt/vm0-runner/.lock" || true
          echo "Unlocked runner host: $RUNNER_HOST"

  # Build E2B templates (development account)
  # Uses repository-level E2B_API_KEY secret
  build-e2b-template:
    runs-on: ubuntu-latest
    container:
      image: ghcr.io/vm0-ai/vm0-toolchain:20260203
    needs: [prepare]
    # Build on PR or main push when E2B templates changed, skip release-please commits
    if: |
      (github.event_name != 'push' || !startsWith(github.event.head_commit.message, 'chore: release')) &&
      needs.prepare.outputs.e2b-changed == 'true'
    steps:
      - uses: actions/checkout@v6
      - uses: ./.github/actions/toolchain-init

      - name: Build E2B templates
        working-directory: turbo
        env:
          E2B_API_KEY: ${{ secrets.E2B_API_KEY }}
        run: |
          pnpm e2b:build
          pnpm e2b:codex:build
          pnpm e2b:claude-code-github:build
          pnpm e2b:cli:build

      - name: Build summary
        run: echo "✅ E2B templates built successfully (development account)"

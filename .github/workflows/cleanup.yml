name: Cleanup Resources

on:
  pull_request_target:
    types: [closed]

concurrency:
  group: ${{ github.head_ref || github.ref }}
  cancel-in-progress: true

jobs:
  cleanup-runner:
    runs-on: ubuntu-latest
    container:
      image: ghcr.io/vm0-ai/vm0-toolchain:20260116
    steps:
      - uses: actions/checkout@v4

      - name: Check if cleanup needed
        id: check
        env:
          METAL_HOSTS: ${{ secrets.CI_AWS_METAL_RUNNER_HOSTS }}
          SSH_KEY: ${{ secrets.CI_AWS_METAL_RUNNER_SSH_KEY }}
        run: |
          if [ -z "$SSH_KEY" ] || [ -z "$METAL_HOSTS" ]; then
            echo "Metal secrets not available, skipping runner cleanup"
            echo "should-cleanup=false" >> $GITHUB_OUTPUT
          else
            echo "should-cleanup=true" >> $GITHUB_OUTPUT
          fi

      - name: Setup SSH key
        if: steps.check.outputs.should-cleanup == 'true'
        env:
          SSH_KEY: ${{ secrets.CI_AWS_METAL_RUNNER_SSH_KEY }}
        run: |
          SSH_DIR="$HOME/.ssh"
          SSH_KEY_FILE="$SSH_DIR/metal.pem"
          mkdir -p "$SSH_DIR"
          echo "$SSH_KEY" > "$SSH_KEY_FILE"
          chmod 600 "$SSH_KEY_FILE"
          echo "SSH key file created at $SSH_KEY_FILE ($(wc -c < "$SSH_KEY_FILE") bytes)"

      - name: Cleanup runner on metal hosts
        if: steps.check.outputs.should-cleanup == 'true'
        shell: bash
        env:
          PR_NUMBER: ${{ github.event.pull_request.number }}
          METAL_USER: ${{ secrets.CI_AWS_METAL_RUNNER_USER }}
          METAL_HOSTS: ${{ secrets.CI_AWS_METAL_RUNNER_HOSTS }}
        run: |
          SSH_KEY_FILE="$HOME/.ssh/metal.pem"
          SSH_OPTS="-o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null -o ConnectTimeout=10 -i $SSH_KEY_FILE"

          # Parse hosts into array
          IFS=',' read -ra HOSTS <<< "$METAL_HOSTS"
          echo "Checking ${#HOSTS[@]} metal hosts for PR $PR_NUMBER..."

          # Check each host for this PR's lock or runner directory
          for host in "${HOSTS[@]}"; do
            echo ""
            echo "Checking host: $host"

            # Check if lock exists for this PR
            lock_pr=$(ssh $SSH_OPTS ${METAL_USER}@${host} "cat /opt/vm0-runner/.lock/pr 2>/dev/null" || echo "")

            # Also check if runner directory exists for this PR
            runner_exists=$(ssh $SSH_OPTS ${METAL_USER}@${host} "test -d /opt/vm0-runner/pr-${PR_NUMBER} && echo 'yes'" || echo "")

            if [ "$lock_pr" = "$PR_NUMBER" ] || [ "$runner_exists" = "yes" ]; then
              echo "Found PR $PR_NUMBER on $host, cleaning up..."

              # Run Ansible cleanup
              cd ansible
              ansible-playbook \
                -i "${host}," \
                playbooks/cleanup-runner.yml \
                --private-key "$SSH_KEY_FILE" \
                -e "ansible_user=${METAL_USER}" \
                -e "pr_number=${PR_NUMBER}" \
                -v || true
              cd ..

              # Release lock if it belongs to this PR
              if [ "$lock_pr" = "$PR_NUMBER" ]; then
                ssh $SSH_OPTS ${METAL_USER}@${host} "rm -rf /opt/vm0-runner/.lock" || true
                echo "Released lock on $host"
              fi

              echo "Cleanup complete on $host"
            else
              echo "PR $PR_NUMBER not found on $host (lock_pr='$lock_pr', runner_exists='$runner_exists')"
            fi
          done

          echo ""
          echo "Cleanup complete"

  cleanup-database:
    runs-on: ubuntu-latest
    container:
      image: ghcr.io/vm0-ai/vm0-toolchain:20260116
    steps:
      - uses: actions/checkout@v4

      - name: Delete Neon Branch
        uses: ./.github/actions/neon-branch
        with:
          neon-api-key: ${{ secrets.NEON_API_KEY }}
          neon-project-id: ${{ vars.NEON_PROJECT_ID }}
          branch-name: "${{ github.event.pull_request.head.ref }}"
          action: "cleanup"

  cleanup-deployments:
    runs-on: ubuntu-latest
    permissions:
      deployments: write
    steps:
      - name: Delete PR Deployments
        uses: actions/github-script@v7
        with:
          script: |
            const branchName = context.payload.pull_request.head.ref;
            const sha = context.payload.pull_request.head.sha;

            console.log(`Cleaning up deployments for branch: ${branchName}, sha: ${sha}`);

            // Get all deployments and filter by branch name
            const allDeployments = await github.rest.repos.listDeployments({
              owner: context.repo.owner,
              repo: context.repo.repo,
              per_page: 100
            });

            // Filter deployments that belong to this branch
            const branchDeployments = allDeployments.data.filter(deployment => {
              // Match by ref or environment name containing branch
              return deployment.ref === branchName ||
                     deployment.ref === `refs/heads/${branchName}` ||
                     deployment.ref === sha ||
                     deployment.environment?.includes(`preview/${branchName}`);
            });

            console.log(`Found ${branchDeployments.length} deployments to delete`);

            // Delete each deployment (must mark as inactive first)
            for (const deployment of branchDeployments) {
              console.log(`Deleting deployment ${deployment.id} (${deployment.environment})`);

              // Step 1: Mark as inactive
              await github.rest.repos.createDeploymentStatus({
                owner: context.repo.owner,
                repo: context.repo.repo,
                deployment_id: deployment.id,
                state: 'inactive',
                description: 'PR closed - cleaning up'
              });

              // Step 2: Delete the deployment
              try {
                await github.rest.repos.deleteDeployment({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  deployment_id: deployment.id
                });
                console.log(`Successfully deleted deployment ${deployment.id}`);
              } catch (error) {
                console.error(`Failed to delete deployment ${deployment.id}: ${error.message}`);
              }
            }
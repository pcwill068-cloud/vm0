name: release-please

on:
  workflow_run:
    workflows: ["Turbo"]
    branches: ["main"]
    types:
      - completed

concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: false

permissions:
  contents: write
  pull-requests: write
  issues: write
  packages: write

jobs:
  release-please:
    runs-on: ubuntu-latest
    if: ${{ github.event.workflow_run.conclusion == 'success' }}
    outputs:
      releases_created: ${{ steps.release.outputs.releases_created }}
      cli_release_created: ${{ steps.release.outputs['turbo/apps/cli--release_created'] }}
      web_release_created: ${{ steps.release.outputs['turbo/apps/web--release_created'] }}
      docs_release_created: ${{ steps.release.outputs['turbo/apps/docs--release_created'] }}
      runner_release_created: ${{ steps.release.outputs['turbo/apps/runner--release_created'] }}
      platform_release_created: ${{ steps.release.outputs['turbo/apps/platform--release_created'] }}
      web_version: ${{ steps.release.outputs['turbo/apps/web--version'] }}
      platform_version: ${{ steps.release.outputs['turbo/apps/platform--version'] }}
    steps:
      - uses: googleapis/release-please-action@v4
        id: release
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
          config-file: release-please-config.json
          manifest-file: .release-please-manifest.json

  # Run database migrations in production
  migrate-production:
    needs: release-please
    if: ${{ needs.release-please.outputs.web_release_created == 'true' }}
    runs-on: ubuntu-latest
    container:
      image: ghcr.io/vm0-ai/vm0-toolchain:20260203
    permissions:
      contents: read
    environment: production
    steps:
      - uses: actions/checkout@v6
      - uses: ./.github/actions/toolchain-init

      - name: Install neonctl
        run: npm install -g neonctl@2.15.0

      - name: Notify Slack - Starting
        id: slack-start
        if: ${{ vars.SLACK_RELEASE_CHANNEL_ID != '' }}
        uses: slackapi/slack-github-action@v2.1.1
        with:
          method: chat.postMessage
          token: ${{ secrets.CI_SLACK_BOT_TOKEN }}
          payload: |
            channel: ${{ vars.SLACK_RELEASE_CHANNEL_ID }}
            text: "*Database Migration* starting..."

      - name: Get Production Database URL
        id: get-db-url
        run: |
          # Get the main branch database URL (production)
          DATABASE_URL=$(neonctl connection-string production --project-id ${{ vars.NEON_PROJECT_ID }} --database-name neondb --pooled)
          echo "database-url=$DATABASE_URL" >> $GITHUB_OUTPUT
        env:
          NEON_API_KEY: ${{ secrets.NEON_API_KEY }}

      - name: Run Production Migrations
        run: |
          cd turbo && pnpm -F web db:migrate
        env:
          DATABASE_URL: ${{ steps.get-db-url.outputs.database-url }}
          CLERK_SECRET_KEY: ${{ secrets.CLERK_SECRET_KEY }}
          CLERK_PUBLISHABLE_KEY: ${{ vars.CLERK_PUBLISHABLE_KEY }}

      - name: Notify Slack - Success
        if: ${{ success() && steps.slack-start.outputs.ts }}
        uses: slackapi/slack-github-action@v2.1.1
        with:
          method: chat.update
          token: ${{ secrets.CI_SLACK_BOT_TOKEN }}
          payload: |
            channel: ${{ vars.SLACK_RELEASE_CHANNEL_ID }}
            ts: "${{ steps.slack-start.outputs.ts }}"
            text: "*Database Migration* starting...\n:white_check_mark: Migration completed"

      - name: Notify Slack - Failure
        if: ${{ failure() && steps.slack-start.outputs.ts }}
        uses: slackapi/slack-github-action@v2.1.1
        with:
          method: chat.update
          token: ${{ secrets.CI_SLACK_BOT_TOKEN }}
          payload: |
            channel: ${{ vars.SLACK_RELEASE_CHANNEL_ID }}
            ts: "${{ steps.slack-start.outputs.ts }}"
            text: "*Database Migration* starting...\n:x: Migration failed"

  # Deploy web app to production
  deploy-web-production:
    needs: [release-please, migrate-production]
    if: ${{ needs.release-please.outputs.web_release_created == 'true' }}
    runs-on: ubuntu-latest
    container:
      image: ghcr.io/vm0-ai/vm0-toolchain:20260203
    permissions:
      contents: read
      deployments: write
    environment: production
    steps:
      - uses: actions/checkout@v6
      - uses: ./.github/actions/toolchain-init

      - name: Install neonctl
        run: npm install -g neonctl@2.15.0

      - name: Notify Slack - Starting
        id: slack-start
        if: ${{ vars.SLACK_RELEASE_CHANNEL_ID != '' }}
        uses: slackapi/slack-github-action@v2.1.1
        with:
          method: chat.postMessage
          token: ${{ secrets.CI_SLACK_BOT_TOKEN }}
          payload: |
            channel: ${{ vars.SLACK_RELEASE_CHANNEL_ID }}
            text: "*Web App* deploying to production..."

      - name: Get Production Database URL
        id: get-db-url
        run: |
          # Get the main branch database URL (production)
          DATABASE_URL=$(neonctl connection-string production --project-id ${{ vars.NEON_PROJECT_ID }} --database-name neondb --pooled)
          echo "database-url=$DATABASE_URL" >> $GITHUB_OUTPUT
        env:
          NEON_API_KEY: ${{ secrets.NEON_API_KEY }}

      - name: Deploy Web to Vercel Production
        id: deploy
        uses: ./.github/actions/vercel-deploy
        with:
          vercel-token: ${{ secrets.VERCEL_TOKEN }}
          vercel-org-id: ${{ vars.VERCEL_TEAM_ID }}
          vercel-project-id: ${{ vars.VERCEL_PROJECT_ID_WEB }}
          environment: production
          deployment-env: web
          environment-variables: |
            DATABASE_URL=${{ steps.get-db-url.outputs.database-url }}
            BLOG_BASE_URL=https://www.vm0.ai
            CLERK_PUBLISHABLE_KEY=${{ vars.CLERK_PUBLISHABLE_KEY }}
            CLERK_SECRET_KEY=${{ secrets.CLERK_SECRET_KEY }}
            E2B_API_KEY=${{ secrets.E2B_API_KEY }}
            R2_ACCOUNT_ID=${{ vars.R2_ACCOUNT_ID }}
            R2_ACCESS_KEY_ID=${{ secrets.R2_ACCESS_KEY_ID }}
            R2_SECRET_ACCESS_KEY=${{ secrets.R2_SECRET_ACCESS_KEY }}
            R2_USER_STORAGES_BUCKET_NAME=${{ vars.R2_USER_STORAGES_BUCKET_NAME }}
            SECRETS_ENCRYPTION_KEY=${{ secrets.SECRETS_ENCRYPTION_KEY }}
            AXIOM_TOKEN_SESSIONS=${{ secrets.AXIOM_TOKEN_SESSIONS }}
            AXIOM_TOKEN_TELEMETRY=${{ secrets.AXIOM_TOKEN_TELEMETRY }}
            AXIOM_DATASET_SUFFIX=prod
            CRON_SECRET=${{ secrets.CRON_SECRET }}
            OFFICIAL_RUNNER_SECRET=${{ secrets.OFFICIAL_RUNNER_SECRET }}
            ABLY_API_KEY=${{ secrets.ABLY_API_KEY }}
            CONCURRENT_RUN_LIMIT=1
            CLAUDE_CODE_VERSION_URL=${{ vars.CLAUDE_CODE_VERSION_URL }}
            SLACK_CLIENT_ID=${{ vars.SLACK_CLIENT_ID }}
            SLACK_CLIENT_SECRET=${{ secrets.SLACK_CLIENT_SECRET }}
            SLACK_SIGNING_SECRET=${{ secrets.SLACK_SIGNING_SECRET }}
            SLACK_REDIRECT_BASE_URL=${{ vars.SLACK_REDIRECT_BASE_URL }}
            SLACK_DEFAULT_AGENT=${{ vars.SLACK_DEFAULT_AGENT }}
            SENTRY_DSN_WEB=${{ secrets.SENTRY_DSN_WEB }}
            SENTRY_AUTH_TOKEN=${{ secrets.SENTRY_AUTH_TOKEN }}
            SENTRY_ORG=${{ vars.SENTRY_ORG }}
            SENTRY_PROJECT=${{ vars.SENTRY_PROJECT_WEB }}
            GH_OAUTH_CLIENT_ID=${{ vars.GH_OAUTH_CLIENT_ID }}
            GH_OAUTH_CLIENT_SECRET=${{ secrets.GH_OAUTH_CLIENT_SECRET }}
            NOTION_OAUTH_CLIENT_ID=${{ vars.NOTION_OAUTH_CLIENT_ID }}
            NOTION_OAUTH_CLIENT_SECRET=${{ secrets.NOTION_OAUTH_CLIENT_SECRET }}
            NGROK_API_KEY=${{ secrets.NGROK_API_KEY }}
            NGROK_COMPUTER_CONNECTOR_DOMAIN=${{ vars.NGROK_COMPUTER_CONNECTOR_DOMAIN }}
            PLATFORM_URL=${{ vars.PLATFORM_URL }}
            RESEND_API_KEY=${{ secrets.RESEND_API_KEY }}
            RESEND_WEBHOOK_SECRET=${{ secrets.RESEND_WEBHOOK_SECRET }}
            RESEND_FROM_DOMAIN=${{ vars.RESEND_FROM_DOMAIN }}

      - name: Notify Slack - Success
        if: ${{ success() && steps.slack-start.outputs.ts }}
        uses: slackapi/slack-github-action@v2.1.1
        with:
          method: chat.update
          token: ${{ secrets.CI_SLACK_BOT_TOKEN }}
          payload: |
            channel: ${{ vars.SLACK_RELEASE_CHANNEL_ID }}
            ts: "${{ steps.slack-start.outputs.ts }}"
            text: "*Web App* deploying to production...\n:white_check_mark: Deployed successfully"

      - name: Notify Slack - Failure
        if: ${{ failure() && steps.slack-start.outputs.ts }}
        uses: slackapi/slack-github-action@v2.1.1
        with:
          method: chat.update
          token: ${{ secrets.CI_SLACK_BOT_TOKEN }}
          payload: |
            channel: ${{ vars.SLACK_RELEASE_CHANNEL_ID }}
            ts: "${{ steps.slack-start.outputs.ts }}"
            text: "*Web App* deploying to production...\n:x: Deploy failed"

  # Deploy docs app to production
  deploy-docs-production:
    needs: release-please
    if: ${{ needs.release-please.outputs.docs_release_created == 'true' }}
    runs-on: ubuntu-latest
    container:
      image: ghcr.io/vm0-ai/vm0-toolchain:20260203
    permissions:
      contents: read
      deployments: write
    environment: production
    steps:
      - uses: actions/checkout@v6
      - uses: ./.github/actions/toolchain-init

      - name: Notify Slack - Starting
        id: slack-start
        if: ${{ vars.SLACK_RELEASE_CHANNEL_ID != '' }}
        uses: slackapi/slack-github-action@v2.1.1
        with:
          method: chat.postMessage
          token: ${{ secrets.CI_SLACK_BOT_TOKEN }}
          payload: |
            channel: ${{ vars.SLACK_RELEASE_CHANNEL_ID }}
            text: "*Docs* deploying to production..."

      - name: Deploy Docs to Vercel Production
        id: deploy
        uses: ./.github/actions/vercel-deploy
        with:
          vercel-token: ${{ secrets.VERCEL_TOKEN }}
          vercel-org-id: ${{ vars.VERCEL_TEAM_ID }}
          vercel-project-id: ${{ vars.VERCEL_PROJECT_ID_DOCS }}
          environment: production
          deployment-env: docs

      - name: Notify Slack - Success
        if: ${{ success() && steps.slack-start.outputs.ts }}
        uses: slackapi/slack-github-action@v2.1.1
        with:
          method: chat.update
          token: ${{ secrets.CI_SLACK_BOT_TOKEN }}
          payload: |
            channel: ${{ vars.SLACK_RELEASE_CHANNEL_ID }}
            ts: "${{ steps.slack-start.outputs.ts }}"
            text: "*Docs* deploying to production...\n:white_check_mark: Deployed successfully"

      - name: Notify Slack - Failure
        if: ${{ failure() && steps.slack-start.outputs.ts }}
        uses: slackapi/slack-github-action@v2.1.1
        with:
          method: chat.update
          token: ${{ secrets.CI_SLACK_BOT_TOKEN }}
          payload: |
            channel: ${{ vars.SLACK_RELEASE_CHANNEL_ID }}
            ts: "${{ steps.slack-start.outputs.ts }}"
            text: "*Docs* deploying to production...\n:x: Deploy failed"

  # Deploy platform (Vite SPA) to production
  deploy-platform-production:
    needs: release-please
    if: ${{ needs.release-please.outputs.platform_release_created == 'true' }}
    runs-on: ubuntu-latest
    container:
      image: ghcr.io/vm0-ai/vm0-toolchain:20260203
    permissions:
      contents: read
      deployments: write
    environment: production
    steps:
      - uses: actions/checkout@v6
      - uses: ./.github/actions/toolchain-init

      - name: Notify Slack - Starting
        id: slack-start
        if: ${{ vars.SLACK_RELEASE_CHANNEL_ID != '' }}
        uses: slackapi/slack-github-action@v2.1.1
        with:
          method: chat.postMessage
          token: ${{ secrets.CI_SLACK_BOT_TOKEN }}
          payload: |
            channel: ${{ vars.SLACK_RELEASE_CHANNEL_ID }}
            text: "*Platform* deploying to production..."

      - name: Deploy Platform to Vercel Production
        id: deploy
        uses: ./.github/actions/vercel-deploy
        with:
          vercel-token: ${{ secrets.VERCEL_TOKEN }}
          vercel-org-id: ${{ vars.VERCEL_TEAM_ID }}
          vercel-project-id: ${{ vars.VERCEL_PROJECT_ID_PLATFORM }}
          environment: production
          deployment-env: platform
          environment-variables: |
            VITE_CLERK_PUBLISHABLE_KEY=${{ vars.CLERK_PUBLISHABLE_KEY }}
            VITE_API_URL=https://www.vm0.ai
            VITE_SENTRY_DSN=${{ secrets.SENTRY_DSN_PLATFORM }}
            SENTRY_AUTH_TOKEN=${{ secrets.SENTRY_AUTH_TOKEN }}
            SENTRY_ORG=${{ vars.SENTRY_ORG }}
            SENTRY_PROJECT=${{ vars.SENTRY_PROJECT_PLATFORM }}

      - name: Notify Slack - Success
        if: ${{ success() && steps.slack-start.outputs.ts }}
        uses: slackapi/slack-github-action@v2.1.1
        with:
          method: chat.update
          token: ${{ secrets.CI_SLACK_BOT_TOKEN }}
          payload: |
            channel: ${{ vars.SLACK_RELEASE_CHANNEL_ID }}
            ts: "${{ steps.slack-start.outputs.ts }}"
            text: "*Platform* deploying to production...\n:white_check_mark: Deployed successfully"

      - name: Notify Slack - Failure
        if: ${{ failure() && steps.slack-start.outputs.ts }}
        uses: slackapi/slack-github-action@v2.1.1
        with:
          method: chat.update
          token: ${{ secrets.CI_SLACK_BOT_TOKEN }}
          payload: |
            channel: ${{ vars.SLACK_RELEASE_CHANNEL_ID }}
            ts: "${{ steps.slack-start.outputs.ts }}"
            text: "*Platform* deploying to production...\n:x: Deploy failed"

  publish-npm:
    needs: release-please
    if: ${{ needs.release-please.outputs.cli_release_created == 'true' }}
    runs-on: ubuntu-latest
    environment: npm
    permissions:
      contents: read
      id-token: write
    steps:
      - uses: actions/checkout@v6

      - name: Notify Slack - Starting
        id: slack-start
        if: ${{ vars.SLACK_RELEASE_CHANNEL_ID != '' }}
        uses: slackapi/slack-github-action@v2.1.1
        with:
          method: chat.postMessage
          token: ${{ secrets.CI_SLACK_BOT_TOKEN }}
          payload: |
            channel: ${{ vars.SLACK_RELEASE_CHANNEL_ID }}
            text: "*CLI* publishing to npm..."

      - uses: actions/setup-node@v6
        with:
          node-version: lts/*
          registry-url: 'https://registry.npmjs.org'

      - name: Install pnpm
        run: npm install -g pnpm@latest

      - name: Install dependencies
        run: cd turbo && pnpm install --frozen-lockfile

      - name: Use latest npm for OIDC support
        run: npm install -g npm@latest

      - name: Build CLI
        run: cd turbo && pnpm --filter @vm0/cli build
        env:
          DEFAULT_SENTRY_DSN: ${{ vars.SENTRY_DSN_CLI }}

      - name: Publish to npm with OIDC
        run: cd turbo/apps/cli/dist && npm publish --access public

      - name: Notify Slack - Success
        if: ${{ success() && steps.slack-start.outputs.ts }}
        uses: slackapi/slack-github-action@v2.1.1
        with:
          method: chat.update
          token: ${{ secrets.CI_SLACK_BOT_TOKEN }}
          payload: |
            channel: ${{ vars.SLACK_RELEASE_CHANNEL_ID }}
            ts: "${{ steps.slack-start.outputs.ts }}"
            text: "*CLI* publishing to npm...\n:white_check_mark: Published successfully"

      - name: Notify Slack - Failure
        if: ${{ failure() && steps.slack-start.outputs.ts }}
        uses: slackapi/slack-github-action@v2.1.1
        with:
          method: chat.update
          token: ${{ secrets.CI_SLACK_BOT_TOKEN }}
          payload: |
            channel: ${{ vars.SLACK_RELEASE_CHANNEL_ID }}
            ts: "${{ steps.slack-start.outputs.ts }}"
            text: "*CLI* publishing to npm...\n:x: Publish failed"

  publish-runner-npm:
    needs: release-please
    if: ${{ needs.release-please.outputs.runner_release_created == 'true' }}
    runs-on: ubuntu-latest
    environment: npm
    permissions:
      contents: read
      id-token: write
    steps:
      - uses: actions/checkout@v6

      - name: Notify Slack - Starting
        id: slack-start
        if: ${{ vars.SLACK_RELEASE_CHANNEL_ID != '' }}
        uses: slackapi/slack-github-action@v2.1.1
        with:
          method: chat.postMessage
          token: ${{ secrets.CI_SLACK_BOT_TOKEN }}
          payload: |
            channel: ${{ vars.SLACK_RELEASE_CHANNEL_ID }}
            text: "*Runner* publishing to npm..."

      - uses: actions/setup-node@v6
        with:
          node-version: lts/*
          registry-url: 'https://registry.npmjs.org'

      - name: Install pnpm
        run: npm install -g pnpm@latest

      - name: Install dependencies
        run: cd turbo && pnpm install --frozen-lockfile

      - name: Use latest npm for OIDC support
        run: npm install -g npm@latest

      - name: Build Runner
        run: cd turbo && pnpm --filter @vm0/runner build

      - name: Publish to npm with OIDC
        run: cd turbo/apps/runner/dist && npm publish --access public

      - name: Notify Slack - Success
        if: ${{ success() && steps.slack-start.outputs.ts }}
        uses: slackapi/slack-github-action@v2.1.1
        with:
          method: chat.update
          token: ${{ secrets.CI_SLACK_BOT_TOKEN }}
          payload: |
            channel: ${{ vars.SLACK_RELEASE_CHANNEL_ID }}
            ts: "${{ steps.slack-start.outputs.ts }}"
            text: "*Runner* publishing to npm...\n:white_check_mark: Published successfully"

      - name: Notify Slack - Failure
        if: ${{ failure() && steps.slack-start.outputs.ts }}
        uses: slackapi/slack-github-action@v2.1.1
        with:
          method: chat.update
          token: ${{ secrets.CI_SLACK_BOT_TOKEN }}
          payload: |
            channel: ${{ vars.SLACK_RELEASE_CHANNEL_ID }}
            ts: "${{ steps.slack-start.outputs.ts }}"
            text: "*Runner* publishing to npm...\n:x: Publish failed"

  # Deploy runner to production metal instances
  deploy-runner-production:
    needs: [release-please, publish-runner-npm]
    if: ${{ needs.release-please.outputs.runner_release_created == 'true' }}
    runs-on: ubuntu-latest
    container:
      image: ghcr.io/vm0-ai/vm0-toolchain-rust:20260203
    permissions:
      contents: read
    environment: production
    steps:
      - uses: actions/checkout@v6
      - uses: ./.github/actions/toolchain-init

      - name: Install Python3 and Ansible
        run: |
          apt-get update && apt-get install -y python3 python3-pip
          pip3 install ansible

      - name: Notify Slack - Starting
        id: slack-start
        if: ${{ vars.SLACK_RELEASE_CHANNEL_ID != '' }}
        uses: slackapi/slack-github-action@v2.1.1
        with:
          method: chat.postMessage
          token: ${{ secrets.CI_SLACK_BOT_TOKEN }}
          payload: |
            channel: ${{ vars.SLACK_RELEASE_CHANNEL_ID }}
            text: "*Runner* deploying to production servers..."

      - name: Build Sandbox Scripts
        run: cd turbo && pnpm turbo run build --filter=@vm0/sandbox-scripts

      # Cross-compile Rust binaries for ARM64 (metal runners are ARM64)
      - name: Build guest binaries for ARM64
        run: |
          cd crates
          CARGO_TARGET_AARCH64_UNKNOWN_LINUX_MUSL_LINKER=aarch64-linux-gnu-gcc \
            cargo build --release --target aarch64-unknown-linux-musl -p guest-init -p guest-download -p guest-agent -p guest-mock-claude
          ls -la target/aarch64-unknown-linux-musl/release/guest-init
          ls -la target/aarch64-unknown-linux-musl/release/guest-download
          ls -la target/aarch64-unknown-linux-musl/release/guest-agent
          ls -la target/aarch64-unknown-linux-musl/release/guest-mock-claude

      - name: Build runner bundle
        run: |
          # Build runner (use subshell to preserve working directory)
          (cd turbo && pnpm --filter @vm0/runner build)

          # Create staging directory with built files
          STAGING_DIR="/tmp/vm0-runner-bundle"
          rm -rf "$STAGING_DIR"
          mkdir -p "$STAGING_DIR"
          cp -r turbo/apps/runner/dist/* "$STAGING_DIR/"

          # Install production dependencies
          (cd "$STAGING_DIR" && npm install --omit=dev)

          # Create tarball
          tar -czf /tmp/vm0-runner-bundle.tar.gz -C /tmp vm0-runner-bundle

          echo "Bundle created at /tmp/vm0-runner-bundle.tar.gz"
          ls -lh /tmp/vm0-runner-bundle.tar.gz

      - name: Deploy to production with Ansible
        env:
          AWS_METAL_RUNNER_HOSTS: ${{ secrets.AWS_METAL_RUNNER_HOSTS }}
          AWS_METAL_RUNNER_USER: ${{ vars.AWS_METAL_RUNNER_USER }}
          AWS_METAL_RUNNER_SSH_KEY: ${{ secrets.AWS_METAL_RUNNER_SSH_KEY }}
          OFFICIAL_RUNNER_SECRET: ${{ secrets.OFFICIAL_RUNNER_SECRET }}
        run: |
          # Setup SSH key
          mkdir -p ~/.ssh
          echo "$AWS_METAL_RUNNER_SSH_KEY" > ~/.ssh/prod-runner.pem
          chmod 600 ~/.ssh/prod-runner.pem

          # Run Ansible playbook with rolling deployment
          cd ansible
          ansible-playbook \
            -i "${AWS_METAL_RUNNER_HOSTS}," \
            playbooks/deploy-runner.yml \
            --private-key ~/.ssh/prod-runner.pem \
            -e "ansible_user=${AWS_METAL_RUNNER_USER}" \
            -e "official_runner_secret=${OFFICIAL_RUNNER_SECRET}" \
            -e "api_url=https://www.vm0.ai" \
            -e "runner_bundle_path=/tmp/vm0-runner-bundle.tar.gz" \
            -v

      - name: Notify Slack - Success
        if: ${{ success() && steps.slack-start.outputs.ts }}
        uses: slackapi/slack-github-action@v2.1.1
        with:
          method: chat.update
          token: ${{ secrets.CI_SLACK_BOT_TOKEN }}
          payload: |
            channel: ${{ vars.SLACK_RELEASE_CHANNEL_ID }}
            ts: "${{ steps.slack-start.outputs.ts }}"
            text: "*Runner* deploying to production servers...\n:white_check_mark: Deployed successfully"

      - name: Notify Slack - Failure
        if: ${{ failure() && steps.slack-start.outputs.ts }}
        uses: slackapi/slack-github-action@v2.1.1
        with:
          method: chat.update
          token: ${{ secrets.CI_SLACK_BOT_TOKEN }}
          payload: |
            channel: ${{ vars.SLACK_RELEASE_CHANNEL_ID }}
            ts: "${{ steps.slack-start.outputs.ts }}"
            text: "*Runner* deploying to production servers...\n:x: Deploy failed"

  # Build E2B templates to production account
  # Uses production environment E2B_API_KEY secret
  build-e2b-template-production:
    needs: [release-please]
    # Build when any release is created
    if: ${{ needs.release-please.outputs.releases_created == 'true' }}
    runs-on: ubuntu-latest
    container:
      image: ghcr.io/vm0-ai/vm0-toolchain:20260203
    permissions:
      contents: read
    environment: production
    steps:
      - uses: actions/checkout@v6
      - uses: ./.github/actions/toolchain-init

      - name: Build E2B templates
        working-directory: turbo
        env:
          E2B_API_KEY: ${{ secrets.E2B_API_KEY }}
        run: |
          pnpm e2b:build
          pnpm e2b:codex:build
          pnpm e2b:claude-code-github:build
          pnpm e2b:cli:build

      - name: Build summary
        run: echo "âœ… E2B templates built successfully (production account)"

  # Publish Docker images to GHCR on release
  # Uses native ARM runners instead of QEMU for faster builds
  # Pattern: build per-platform digests in parallel, then merge into multi-arch manifest
  publish-docker-web-build:
    needs: release-please
    if: ${{ needs.release-please.outputs.web_release_created == 'true' }}
    strategy:
      matrix:
        include:
          - platform: linux/amd64
            runner: ubuntu-latest
          - platform: linux/arm64
            runner: ubuntu-24.04-arm
    runs-on: ${{ matrix.runner }}
    permissions:
      contents: read
      packages: write
    steps:
      - uses: actions/checkout@v6

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Log in to GitHub Container Registry
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Build and push by digest
        id: build
        uses: docker/build-push-action@v6
        with:
          context: .
          file: docker/Dockerfile.web
          platforms: ${{ matrix.platform }}
          outputs: type=image,name=ghcr.io/vm0-ai/vm0,push-by-digest=true,name-canonical=true,push=true
          cache-from: type=gha,scope=web-${{ matrix.platform }}
          cache-to: type=gha,scope=web-${{ matrix.platform }},mode=max
          labels: |
            org.opencontainers.image.source=${{ github.event.repository.html_url }}
            org.opencontainers.image.revision=${{ github.sha }}
            org.opencontainers.image.version=${{ needs.release-please.outputs.web_version }}

      - name: Export digest
        run: |
          mkdir -p /tmp/digests
          digest="${{ steps.build.outputs.digest }}"
          touch "/tmp/digests/${digest#sha256:}"

      - name: Upload digest
        uses: actions/upload-artifact@v6
        with:
          name: web-digest-${{ matrix.platform == 'linux/amd64' && 'amd64' || 'arm64' }}
          path: /tmp/digests/*
          if-no-files-found: error
          retention-days: 1

  publish-docker-web-merge:
    needs: [release-please, publish-docker-web-build]
    if: ${{ needs.release-please.outputs.web_release_created == 'true' }}
    runs-on: ubuntu-latest
    permissions:
      contents: read
      packages: write
    steps:
      - name: Download digests
        uses: actions/download-artifact@v7
        with:
          path: /tmp/digests
          pattern: web-digest-*
          merge-multiple: true

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Log in to GitHub Container Registry
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Create manifest and push
        working-directory: /tmp/digests
        run: |
          docker buildx imagetools create \
            -t ghcr.io/vm0-ai/vm0:${{ needs.release-please.outputs.web_version }} \
            -t ghcr.io/vm0-ai/vm0:latest \
            $(printf 'ghcr.io/vm0-ai/vm0@sha256:%s ' *)

  publish-docker-platform-build:
    needs: release-please
    if: ${{ needs.release-please.outputs.platform_release_created == 'true' }}
    strategy:
      matrix:
        include:
          - platform: linux/amd64
            runner: ubuntu-latest
          - platform: linux/arm64
            runner: ubuntu-24.04-arm
    runs-on: ${{ matrix.runner }}
    permissions:
      contents: read
      packages: write
    steps:
      - uses: actions/checkout@v6

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Log in to GitHub Container Registry
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Build and push by digest
        id: build
        uses: docker/build-push-action@v6
        with:
          context: .
          file: docker/Dockerfile.platform
          platforms: ${{ matrix.platform }}
          outputs: type=image,name=ghcr.io/vm0-ai/vm0-platform,push-by-digest=true,name-canonical=true,push=true
          cache-from: type=gha,scope=platform-${{ matrix.platform }}
          cache-to: type=gha,scope=platform-${{ matrix.platform }},mode=max
          labels: |
            org.opencontainers.image.source=${{ github.event.repository.html_url }}
            org.opencontainers.image.revision=${{ github.sha }}
            org.opencontainers.image.version=${{ needs.release-please.outputs.platform_version }}

      - name: Export digest
        run: |
          mkdir -p /tmp/digests
          digest="${{ steps.build.outputs.digest }}"
          touch "/tmp/digests/${digest#sha256:}"

      - name: Upload digest
        uses: actions/upload-artifact@v6
        with:
          name: platform-digest-${{ matrix.platform == 'linux/amd64' && 'amd64' || 'arm64' }}
          path: /tmp/digests/*
          if-no-files-found: error
          retention-days: 1

  publish-docker-platform-merge:
    needs: [release-please, publish-docker-platform-build]
    if: ${{ needs.release-please.outputs.platform_release_created == 'true' }}
    runs-on: ubuntu-latest
    permissions:
      contents: read
      packages: write
    steps:
      - name: Download digests
        uses: actions/download-artifact@v7
        with:
          path: /tmp/digests
          pattern: platform-digest-*
          merge-multiple: true

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Log in to GitHub Container Registry
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Create manifest and push
        working-directory: /tmp/digests
        run: |
          docker buildx imagetools create \
            -t ghcr.io/vm0-ai/vm0-platform:${{ needs.release-please.outputs.platform_version }} \
            -t ghcr.io/vm0-ai/vm0-platform:latest \
            $(printf 'ghcr.io/vm0-ai/vm0-platform@sha256:%s ' *)

  publish-docker-sandbox-build:
    needs: release-please
    if: ${{ needs.release-please.outputs.web_release_created == 'true' }}
    strategy:
      matrix:
        include:
          - platform: linux/amd64
            runner: ubuntu-latest
          - platform: linux/arm64
            runner: ubuntu-24.04-arm
    runs-on: ${{ matrix.runner }}
    permissions:
      contents: read
      packages: write
    steps:
      - uses: actions/checkout@v6

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Log in to GitHub Container Registry
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Build and push by digest
        id: build
        uses: docker/build-push-action@v6
        with:
          context: .
          file: docker/Dockerfile.sandbox
          platforms: ${{ matrix.platform }}
          outputs: type=image,name=ghcr.io/vm0-ai/vm0-sandbox,push-by-digest=true,name-canonical=true,push=true
          cache-from: type=gha,scope=sandbox-${{ matrix.platform }}
          cache-to: type=gha,scope=sandbox-${{ matrix.platform }},mode=max
          labels: |
            org.opencontainers.image.source=${{ github.event.repository.html_url }}
            org.opencontainers.image.revision=${{ github.sha }}
            org.opencontainers.image.version=${{ needs.release-please.outputs.web_version }}

      - name: Export digest
        run: |
          mkdir -p /tmp/digests
          digest="${{ steps.build.outputs.digest }}"
          touch "/tmp/digests/${digest#sha256:}"

      - name: Upload digest
        uses: actions/upload-artifact@v6
        with:
          name: sandbox-digest-${{ matrix.platform == 'linux/amd64' && 'amd64' || 'arm64' }}
          path: /tmp/digests/*
          if-no-files-found: error
          retention-days: 1

  publish-docker-sandbox-merge:
    needs: [release-please, publish-docker-sandbox-build]
    if: ${{ needs.release-please.outputs.web_release_created == 'true' }}
    runs-on: ubuntu-latest
    permissions:
      contents: read
      packages: write
    steps:
      - name: Download digests
        uses: actions/download-artifact@v7
        with:
          path: /tmp/digests
          pattern: sandbox-digest-*
          merge-multiple: true

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Log in to GitHub Container Registry
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Create manifest and push
        working-directory: /tmp/digests
        run: |
          docker buildx imagetools create \
            -t ghcr.io/vm0-ai/vm0-sandbox:${{ needs.release-please.outputs.web_version }} \
            -t ghcr.io/vm0-ai/vm0-sandbox:latest \
            $(printf 'ghcr.io/vm0-ai/vm0-sandbox@sha256:%s ' *)

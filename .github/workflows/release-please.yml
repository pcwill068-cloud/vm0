name: release-please

on:
  workflow_run:
    workflows: ["Turbo"]
    branches: ["main"]
    types:
      - completed

permissions:
  contents: write
  pull-requests: write
  issues: write

jobs:
  release-please:
    runs-on: ubuntu-latest
    if: ${{ github.event.workflow_run.conclusion == 'success' }}
    outputs:
      release_created: ${{ steps.release.outputs.release_created }}
      cli_release_created: ${{ steps.release.outputs['turbo/apps/cli--release_created'] }}
      web_release_created: ${{ steps.release.outputs['turbo/apps/web--release_created'] }}
      docs_release_created: ${{ steps.release.outputs['turbo/apps/docs--release_created'] }}
      runner_release_created: ${{ steps.release.outputs['turbo/apps/runner--release_created'] }}
      app_release_created: ${{ steps.release.outputs['turbo/apps/app--release_created'] }}
    steps:
      - uses: googleapis/release-please-action@v4
        id: release
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
          config-file: release-please-config.json
          manifest-file: .release-please-manifest.json

  # Run database migrations in production
  migrate-production:
    needs: release-please
    if: ${{ needs.release-please.outputs.web_release_created == 'true' }}
    runs-on: ubuntu-latest
    container:
      image: ghcr.io/vm0-ai/vm0-toolchain:829341a
    permissions:
      contents: read
    steps:
      - uses: actions/checkout@v4
      - uses: ./.github/actions/toolchain-init

      - name: Get Production Database URL
        id: get-db-url
        run: |
          # Get the main branch database URL (production)
          DATABASE_URL=$(neonctl connection-string production --project-id ${{ vars.NEON_PROJECT_ID }} --database-name neondb --pooled)
          echo "database-url=$DATABASE_URL" >> $GITHUB_OUTPUT
        env:
          NEON_API_KEY: ${{ secrets.NEON_API_KEY }}

      - name: Run Production Migrations
        run: |
          cd turbo && pnpm -F web db:migrate
        env:
          DATABASE_URL: ${{ steps.get-db-url.outputs.database-url }}
          CLERK_SECRET_KEY: ${{ secrets.CLERK_SECRET_KEY }}
          NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY: ${{ vars.NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY }}

  # Deploy web app to production
  deploy-web-production:
    needs: [release-please, migrate-production]
    if: ${{ needs.release-please.outputs.web_release_created == 'true' }}
    runs-on: ubuntu-latest
    container:
      image: ghcr.io/vm0-ai/vm0-toolchain:829341a
    permissions:
      contents: read
      deployments: write
    environment: production
    steps:
      - uses: actions/checkout@v4
      - uses: ./.github/actions/toolchain-init

      - name: Get Production Database URL
        id: get-db-url
        run: |
          # Get the main branch database URL (production)
          DATABASE_URL=$(neonctl connection-string production --project-id ${{ vars.NEON_PROJECT_ID }} --database-name neondb --pooled)
          echo "database-url=$DATABASE_URL" >> $GITHUB_OUTPUT
        env:
          NEON_API_KEY: ${{ secrets.NEON_API_KEY }}

      - name: Deploy Web to Vercel Production
        id: deploy
        uses: ./.github/actions/vercel-deploy
        with:
          vercel-token: ${{ secrets.VERCEL_TOKEN }}
          vercel-org-id: ${{ vars.VERCEL_TEAM_ID }}
          vercel-project-id: ${{ vars.VERCEL_PROJECT_ID_WEB }}
          environment: production
          deployment-env: web
          environment-variables: |
            DATABASE_URL=${{ steps.get-db-url.outputs.database-url }}
            NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY=${{ vars.NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY }}
            CLERK_SECRET_KEY=${{ secrets.CLERK_SECRET_KEY }}
            E2B_API_KEY=${{ secrets.E2B_API_KEY }}
            E2B_TEMPLATE_NAME=${{ secrets.E2B_TEMPLATE_NAME }}
            R2_ACCOUNT_ID=${{ secrets.R2_ACCOUNT_ID }}
            R2_ACCESS_KEY_ID=${{ secrets.R2_ACCESS_KEY_ID }}
            R2_SECRET_ACCESS_KEY=${{ secrets.R2_SECRET_ACCESS_KEY }}
            R2_USER_STORAGES_BUCKET_NAME=${{ secrets.R2_USER_STORAGES_BUCKET_NAME }}
            SECRETS_ENCRYPTION_KEY=${{ secrets.SECRETS_ENCRYPTION_KEY }}
            AXIOM_TOKEN=${{ secrets.AXIOM_TOKEN }}
            CRON_SECRET=${{ secrets.CRON_SECRET }}
            OFFICIAL_RUNNER_SECRET=${{ secrets.OFFICIAL_RUNNER_SECRET }}
            DEBUG=*

  # Deploy docs app to production
  deploy-docs-production:
    needs: release-please
    if: ${{ needs.release-please.outputs.docs_release_created == 'true' }}
    runs-on: ubuntu-latest
    container:
      image: ghcr.io/vm0-ai/vm0-toolchain:829341a
    permissions:
      contents: read
      deployments: write
    steps:
      - uses: actions/checkout@v4
      - uses: ./.github/actions/toolchain-init

      - name: Deploy Docs to Vercel Production
        id: deploy
        uses: ./.github/actions/vercel-deploy
        with:
          vercel-token: ${{ secrets.VERCEL_TOKEN }}
          vercel-org-id: ${{ vars.VERCEL_TEAM_ID }}
          vercel-project-id: ${{ vars.VERCEL_PROJECT_ID_DOCS }}
          environment: production
          deployment-env: docs

  # Deploy app (Vite SPA) to production
  deploy-app-production:
    needs: release-please
    if: ${{ needs.release-please.outputs.app_release_created == 'true' }}
    runs-on: ubuntu-latest
    container:
      image: ghcr.io/vm0-ai/vm0-toolchain:829341a
    permissions:
      contents: read
      deployments: write
    steps:
      - uses: actions/checkout@v4
      - uses: ./.github/actions/toolchain-init

      - name: Deploy App to Vercel Production
        id: deploy
        uses: ./.github/actions/vercel-deploy
        with:
          vercel-token: ${{ secrets.VERCEL_TOKEN }}
          vercel-org-id: ${{ vars.VERCEL_TEAM_ID }}
          vercel-project-id: ${{ vars.VERCEL_PROJECT_ID_APP }}
          environment: production
          deployment-env: app
          environment-variables: |
            VITE_CLERK_PUBLISHABLE_KEY=${{ vars.NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY }}
            VITE_API_URL=https://www.vm0.ai

  publish-npm:
    needs: release-please
    if: ${{ needs.release-please.outputs.cli_release_created == 'true' }}
    runs-on: ubuntu-latest
    environment: npm
    permissions:
      contents: read
      id-token: write
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-node@v4
        with:
          node-version: lts/*
          registry-url: 'https://registry.npmjs.org'

      - name: Install pnpm
        run: npm install -g pnpm@latest

      - name: Install dependencies
        run: cd turbo && pnpm install --frozen-lockfile

      - name: Use latest npm for OIDC support
        run: npm install -g npm@latest

      - name: Build CLI
        run: cd turbo && pnpm -F @vm0/cli build

      - name: Publish to npm with OIDC
        run: cd turbo/apps/cli/dist && npm publish --access public

  publish-runner-npm:
    needs: release-please
    if: ${{ needs.release-please.outputs.runner_release_created == 'true' }}
    runs-on: ubuntu-latest
    environment: npm
    permissions:
      contents: read
      id-token: write
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-node@v4
        with:
          node-version: lts/*
          registry-url: 'https://registry.npmjs.org'

      - name: Install pnpm
        run: npm install -g pnpm@latest

      - name: Install dependencies
        run: cd turbo && pnpm install --frozen-lockfile

      - name: Use latest npm for OIDC support
        run: npm install -g npm@latest

      - name: Build Runner
        run: cd turbo && pnpm -F @vm0/runner build

      - name: Publish to npm with OIDC
        run: cd turbo/apps/runner/dist && npm publish --access public

  # Deploy runner to production metal instances
  deploy-runner-production:
    needs: [release-please, publish-runner-npm]
    if: ${{ needs.release-please.outputs.runner_release_created == 'true' }}
    runs-on: ubuntu-latest
    container:
      image: ghcr.io/vm0-ai/vm0-toolchain:829341a
    permissions:
      contents: read
    steps:
      - uses: actions/checkout@v4
      - uses: ./.github/actions/toolchain-init

      - name: Install Ansible
        run: apt-get update && apt-get install -y python3-pip && pip3 install ansible

      - name: Build runner bundle
        run: |
          # Build runner (use subshell to preserve working directory)
          (cd turbo && pnpm -F @vm0/runner build)

          # Create staging directory with built files
          STAGING_DIR="/tmp/vm0-runner-bundle"
          rm -rf "$STAGING_DIR"
          mkdir -p "$STAGING_DIR"
          cp -r turbo/apps/runner/dist/* "$STAGING_DIR/"

          # Install production dependencies
          (cd "$STAGING_DIR" && npm install --omit=dev)

          # Create tarball
          tar -czf /tmp/vm0-runner-bundle.tar.gz -C /tmp vm0-runner-bundle

          echo "Bundle created at /tmp/vm0-runner-bundle.tar.gz"
          ls -lh /tmp/vm0-runner-bundle.tar.gz

      - name: Deploy to production with Ansible
        env:
          AWS_METAL_RUNNER_HOSTS: ${{ secrets.AWS_METAL_RUNNER_HOSTS }}
          AWS_METAL_RUNNER_USER: ${{ secrets.AWS_METAL_RUNNER_USER }}
          AWS_METAL_RUNNER_SSH_KEY: ${{ secrets.AWS_METAL_RUNNER_SSH_KEY }}
          OFFICIAL_RUNNER_SECRET: ${{ secrets.OFFICIAL_RUNNER_SECRET }}
        run: |
          # Setup SSH key
          mkdir -p ~/.ssh
          echo "$AWS_METAL_RUNNER_SSH_KEY" > ~/.ssh/prod-runner.pem
          chmod 600 ~/.ssh/prod-runner.pem

          # Run Ansible playbook with rolling deployment
          cd ansible
          ansible-playbook \
            -i "${AWS_METAL_RUNNER_HOSTS}," \
            playbooks/deploy-runner.yml \
            --private-key ~/.ssh/prod-runner.pem \
            -e "ansible_user=${AWS_METAL_RUNNER_USER}" \
            -e "official_runner_secret=${OFFICIAL_RUNNER_SECRET}" \
            -e "api_url=https://www.vm0.ai" \
            -e "runner_bundle_path=/tmp/vm0-runner-bundle.tar.gz" \
            -v

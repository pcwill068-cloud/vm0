name: release-please

on:
  workflow_run:
    workflows: ["Turbo"]
    branches: ["main"]
    types:
      - completed

concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: false

permissions:
  contents: write
  pull-requests: write
  issues: write

jobs:
  release-please:
    runs-on: ubuntu-latest
    if: ${{ github.event.workflow_run.conclusion == 'success' }}
    outputs:
      releases_created: ${{ steps.release.outputs.releases_created }}
      cli_release_created: ${{ steps.release.outputs['turbo/apps/cli--release_created'] }}
      web_release_created: ${{ steps.release.outputs['turbo/apps/web--release_created'] }}
      docs_release_created: ${{ steps.release.outputs['turbo/apps/docs--release_created'] }}
      runner_release_created: ${{ steps.release.outputs['turbo/apps/runner--release_created'] }}
      platform_release_created: ${{ steps.release.outputs['turbo/apps/platform--release_created'] }}
    steps:
      - uses: googleapis/release-please-action@v4
        id: release
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
          config-file: release-please-config.json
          manifest-file: .release-please-manifest.json

  # Run database migrations in production
  migrate-production:
    needs: release-please
    if: ${{ needs.release-please.outputs.web_release_created == 'true' }}
    runs-on: ubuntu-latest
    container:
      image: ghcr.io/vm0-ai/vm0-toolchain:20260203
    permissions:
      contents: read
    environment: production
    steps:
      - uses: actions/checkout@v6
      - uses: ./.github/actions/toolchain-init

      - name: Install neonctl
        run: npm install -g neonctl@2.15.0

      - name: Notify Slack - Starting
        id: slack-start
        if: ${{ vars.SLACK_RELEASE_CHANNEL_ID != '' }}
        uses: slackapi/slack-github-action@v2.1.1
        with:
          method: chat.postMessage
          token: ${{ secrets.CI_SLACK_BOT_TOKEN }}
          payload: |
            channel: ${{ vars.SLACK_RELEASE_CHANNEL_ID }}
            text: "*Database Migration* starting..."

      - name: Get Production Database URL
        id: get-db-url
        run: |
          # Get the main branch database URL (production)
          DATABASE_URL=$(neonctl connection-string production --project-id ${{ vars.NEON_PROJECT_ID }} --database-name neondb --pooled)
          echo "database-url=$DATABASE_URL" >> $GITHUB_OUTPUT
        env:
          NEON_API_KEY: ${{ secrets.NEON_API_KEY }}

      - name: Run Production Migrations
        run: |
          cd turbo && pnpm -F web db:migrate
        env:
          DATABASE_URL: ${{ steps.get-db-url.outputs.database-url }}
          CLERK_SECRET_KEY: ${{ secrets.CLERK_SECRET_KEY }}
          NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY: ${{ vars.CLERK_PUBLISHABLE_KEY }}

      - name: Notify Slack - Success
        if: ${{ success() && steps.slack-start.outputs.ts }}
        uses: slackapi/slack-github-action@v2.1.1
        with:
          method: chat.update
          token: ${{ secrets.CI_SLACK_BOT_TOKEN }}
          payload: |
            channel: ${{ vars.SLACK_RELEASE_CHANNEL_ID }}
            ts: "${{ steps.slack-start.outputs.ts }}"
            text: "*Database Migration* starting...\n:white_check_mark: Migration completed"

      - name: Notify Slack - Failure
        if: ${{ failure() && steps.slack-start.outputs.ts }}
        uses: slackapi/slack-github-action@v2.1.1
        with:
          method: chat.update
          token: ${{ secrets.CI_SLACK_BOT_TOKEN }}
          payload: |
            channel: ${{ vars.SLACK_RELEASE_CHANNEL_ID }}
            ts: "${{ steps.slack-start.outputs.ts }}"
            text: "*Database Migration* starting...\n:x: Migration failed"

  # Deploy web app to production
  deploy-web-production:
    needs: [release-please, migrate-production]
    if: ${{ needs.release-please.outputs.web_release_created == 'true' }}
    runs-on: ubuntu-latest
    container:
      image: ghcr.io/vm0-ai/vm0-toolchain:20260203
    permissions:
      contents: read
      deployments: write
    environment: production
    steps:
      - uses: actions/checkout@v6
      - uses: ./.github/actions/toolchain-init

      - name: Install neonctl
        run: npm install -g neonctl@2.15.0

      - name: Notify Slack - Starting
        id: slack-start
        if: ${{ vars.SLACK_RELEASE_CHANNEL_ID != '' }}
        uses: slackapi/slack-github-action@v2.1.1
        with:
          method: chat.postMessage
          token: ${{ secrets.CI_SLACK_BOT_TOKEN }}
          payload: |
            channel: ${{ vars.SLACK_RELEASE_CHANNEL_ID }}
            text: "*Web App* deploying to production..."

      - name: Get Production Database URL
        id: get-db-url
        run: |
          # Get the main branch database URL (production)
          DATABASE_URL=$(neonctl connection-string production --project-id ${{ vars.NEON_PROJECT_ID }} --database-name neondb --pooled)
          echo "database-url=$DATABASE_URL" >> $GITHUB_OUTPUT
        env:
          NEON_API_KEY: ${{ secrets.NEON_API_KEY }}

      - name: Deploy Web to Vercel Production
        id: deploy
        uses: ./.github/actions/vercel-deploy
        with:
          vercel-token: ${{ secrets.VERCEL_TOKEN }}
          vercel-org-id: ${{ vars.VERCEL_TEAM_ID }}
          vercel-project-id: ${{ vars.VERCEL_PROJECT_ID_WEB }}
          environment: production
          deployment-env: web
          environment-variables: |
            DATABASE_URL=${{ steps.get-db-url.outputs.database-url }}
            NEXT_PUBLIC_BASE_URL=https://www.vm0.ai
            NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY=${{ vars.CLERK_PUBLISHABLE_KEY }}
            CLERK_SECRET_KEY=${{ secrets.CLERK_SECRET_KEY }}
            E2B_API_KEY=${{ secrets.E2B_API_KEY }}
            R2_ACCOUNT_ID=${{ vars.R2_ACCOUNT_ID }}
            R2_ACCESS_KEY_ID=${{ secrets.R2_ACCESS_KEY_ID }}
            R2_SECRET_ACCESS_KEY=${{ secrets.R2_SECRET_ACCESS_KEY }}
            R2_USER_STORAGES_BUCKET_NAME=${{ vars.R2_USER_STORAGES_BUCKET_NAME }}
            SECRETS_ENCRYPTION_KEY=${{ secrets.SECRETS_ENCRYPTION_KEY }}
            AXIOM_TOKEN_SESSIONS=${{ secrets.AXIOM_TOKEN_SESSIONS }}
            AXIOM_TOKEN_TELEMETRY=${{ secrets.AXIOM_TOKEN_TELEMETRY }}
            AXIOM_DATASET_SUFFIX=prod
            CRON_SECRET=${{ secrets.CRON_SECRET }}
            OFFICIAL_RUNNER_SECRET=${{ secrets.OFFICIAL_RUNNER_SECRET }}
            ABLY_API_KEY=${{ secrets.ABLY_API_KEY }}
            CONCURRENT_RUN_LIMIT=1
            CLAUDE_CODE_VERSION_URL=${{ vars.CLAUDE_CODE_VERSION_URL }}
            SLACK_CLIENT_ID=${{ vars.SLACK_CLIENT_ID }}
            SLACK_CLIENT_SECRET=${{ secrets.SLACK_CLIENT_SECRET }}
            SLACK_SIGNING_SECRET=${{ secrets.SLACK_SIGNING_SECRET }}
            SLACK_REDIRECT_BASE_URL=${{ vars.SLACK_REDIRECT_BASE_URL }}
            SENTRY_DSN=${{ secrets.SENTRY_DSN_WEB }}
            NEXT_PUBLIC_SENTRY_DSN=${{ secrets.SENTRY_DSN_WEB }}
            SENTRY_AUTH_TOKEN=${{ secrets.SENTRY_AUTH_TOKEN }}
            SENTRY_ORG=${{ vars.SENTRY_ORG }}
            SENTRY_PROJECT=${{ vars.SENTRY_PROJECT_WEB }}
            GH_OAUTH_CLIENT_ID=${{ vars.GH_OAUTH_CLIENT_ID }}
            GH_OAUTH_CLIENT_SECRET=${{ secrets.GH_OAUTH_CLIENT_SECRET }}
            NOTION_OAUTH_CLIENT_ID=${{ vars.NOTION_OAUTH_CLIENT_ID }}
            NOTION_OAUTH_CLIENT_SECRET=${{ secrets.NOTION_OAUTH_CLIENT_SECRET }}

      - name: Notify Slack - Success
        if: ${{ success() && steps.slack-start.outputs.ts }}
        uses: slackapi/slack-github-action@v2.1.1
        with:
          method: chat.update
          token: ${{ secrets.CI_SLACK_BOT_TOKEN }}
          payload: |
            channel: ${{ vars.SLACK_RELEASE_CHANNEL_ID }}
            ts: "${{ steps.slack-start.outputs.ts }}"
            text: "*Web App* deploying to production...\n:white_check_mark: Deployed successfully"

      - name: Notify Slack - Failure
        if: ${{ failure() && steps.slack-start.outputs.ts }}
        uses: slackapi/slack-github-action@v2.1.1
        with:
          method: chat.update
          token: ${{ secrets.CI_SLACK_BOT_TOKEN }}
          payload: |
            channel: ${{ vars.SLACK_RELEASE_CHANNEL_ID }}
            ts: "${{ steps.slack-start.outputs.ts }}"
            text: "*Web App* deploying to production...\n:x: Deploy failed"

  # Deploy docs app to production
  deploy-docs-production:
    needs: release-please
    if: ${{ needs.release-please.outputs.docs_release_created == 'true' }}
    runs-on: ubuntu-latest
    container:
      image: ghcr.io/vm0-ai/vm0-toolchain:20260203
    permissions:
      contents: read
      deployments: write
    environment: production
    steps:
      - uses: actions/checkout@v6
      - uses: ./.github/actions/toolchain-init

      - name: Notify Slack - Starting
        id: slack-start
        if: ${{ vars.SLACK_RELEASE_CHANNEL_ID != '' }}
        uses: slackapi/slack-github-action@v2.1.1
        with:
          method: chat.postMessage
          token: ${{ secrets.CI_SLACK_BOT_TOKEN }}
          payload: |
            channel: ${{ vars.SLACK_RELEASE_CHANNEL_ID }}
            text: "*Docs* deploying to production..."

      - name: Deploy Docs to Vercel Production
        id: deploy
        uses: ./.github/actions/vercel-deploy
        with:
          vercel-token: ${{ secrets.VERCEL_TOKEN }}
          vercel-org-id: ${{ vars.VERCEL_TEAM_ID }}
          vercel-project-id: ${{ vars.VERCEL_PROJECT_ID_DOCS }}
          environment: production
          deployment-env: docs

      - name: Notify Slack - Success
        if: ${{ success() && steps.slack-start.outputs.ts }}
        uses: slackapi/slack-github-action@v2.1.1
        with:
          method: chat.update
          token: ${{ secrets.CI_SLACK_BOT_TOKEN }}
          payload: |
            channel: ${{ vars.SLACK_RELEASE_CHANNEL_ID }}
            ts: "${{ steps.slack-start.outputs.ts }}"
            text: "*Docs* deploying to production...\n:white_check_mark: Deployed successfully"

      - name: Notify Slack - Failure
        if: ${{ failure() && steps.slack-start.outputs.ts }}
        uses: slackapi/slack-github-action@v2.1.1
        with:
          method: chat.update
          token: ${{ secrets.CI_SLACK_BOT_TOKEN }}
          payload: |
            channel: ${{ vars.SLACK_RELEASE_CHANNEL_ID }}
            ts: "${{ steps.slack-start.outputs.ts }}"
            text: "*Docs* deploying to production...\n:x: Deploy failed"

  # Deploy platform (Vite SPA) to production
  deploy-platform-production:
    needs: release-please
    if: ${{ needs.release-please.outputs.platform_release_created == 'true' }}
    runs-on: ubuntu-latest
    container:
      image: ghcr.io/vm0-ai/vm0-toolchain:20260203
    permissions:
      contents: read
      deployments: write
    environment: production
    steps:
      - uses: actions/checkout@v6
      - uses: ./.github/actions/toolchain-init

      - name: Notify Slack - Starting
        id: slack-start
        if: ${{ vars.SLACK_RELEASE_CHANNEL_ID != '' }}
        uses: slackapi/slack-github-action@v2.1.1
        with:
          method: chat.postMessage
          token: ${{ secrets.CI_SLACK_BOT_TOKEN }}
          payload: |
            channel: ${{ vars.SLACK_RELEASE_CHANNEL_ID }}
            text: "*Platform* deploying to production..."

      - name: Deploy Platform to Vercel Production
        id: deploy
        uses: ./.github/actions/vercel-deploy
        with:
          vercel-token: ${{ secrets.VERCEL_TOKEN }}
          vercel-org-id: ${{ vars.VERCEL_TEAM_ID }}
          vercel-project-id: ${{ vars.VERCEL_PROJECT_ID_PLATFORM }}
          environment: production
          deployment-env: platform
          environment-variables: |
            VITE_CLERK_PUBLISHABLE_KEY=${{ vars.CLERK_PUBLISHABLE_KEY }}
            VITE_API_URL=https://www.vm0.ai
            VITE_SENTRY_DSN=${{ secrets.SENTRY_DSN_PLATFORM }}
            SENTRY_AUTH_TOKEN=${{ secrets.SENTRY_AUTH_TOKEN }}
            SENTRY_ORG=${{ vars.SENTRY_ORG }}
            SENTRY_PROJECT=${{ vars.SENTRY_PROJECT_PLATFORM }}

      - name: Notify Slack - Success
        if: ${{ success() && steps.slack-start.outputs.ts }}
        uses: slackapi/slack-github-action@v2.1.1
        with:
          method: chat.update
          token: ${{ secrets.CI_SLACK_BOT_TOKEN }}
          payload: |
            channel: ${{ vars.SLACK_RELEASE_CHANNEL_ID }}
            ts: "${{ steps.slack-start.outputs.ts }}"
            text: "*Platform* deploying to production...\n:white_check_mark: Deployed successfully"

      - name: Notify Slack - Failure
        if: ${{ failure() && steps.slack-start.outputs.ts }}
        uses: slackapi/slack-github-action@v2.1.1
        with:
          method: chat.update
          token: ${{ secrets.CI_SLACK_BOT_TOKEN }}
          payload: |
            channel: ${{ vars.SLACK_RELEASE_CHANNEL_ID }}
            ts: "${{ steps.slack-start.outputs.ts }}"
            text: "*Platform* deploying to production...\n:x: Deploy failed"

  publish-npm:
    needs: release-please
    if: ${{ needs.release-please.outputs.cli_release_created == 'true' }}
    runs-on: ubuntu-latest
    environment: npm
    permissions:
      contents: read
      id-token: write
    steps:
      - uses: actions/checkout@v6

      - name: Notify Slack - Starting
        id: slack-start
        if: ${{ vars.SLACK_RELEASE_CHANNEL_ID != '' }}
        uses: slackapi/slack-github-action@v2.1.1
        with:
          method: chat.postMessage
          token: ${{ secrets.CI_SLACK_BOT_TOKEN }}
          payload: |
            channel: ${{ vars.SLACK_RELEASE_CHANNEL_ID }}
            text: "*CLI* publishing to npm..."

      - uses: actions/setup-node@v6
        with:
          node-version: lts/*
          registry-url: 'https://registry.npmjs.org'

      - name: Install pnpm
        run: npm install -g pnpm@latest

      - name: Install dependencies
        run: cd turbo && pnpm install --frozen-lockfile

      - name: Use latest npm for OIDC support
        run: npm install -g npm@latest

      - name: Build Core Package
        run: cd turbo && pnpm turbo run build --filter=@vm0/core

      - name: Build CLI
        run: cd turbo && pnpm --filter @vm0/cli build
        env:
          DEFAULT_SENTRY_DSN: ${{ vars.SENTRY_DSN_CLI }}

      - name: Publish to npm with OIDC
        run: cd turbo/apps/cli/dist && npm publish --access public

      - name: Notify Slack - Success
        if: ${{ success() && steps.slack-start.outputs.ts }}
        uses: slackapi/slack-github-action@v2.1.1
        with:
          method: chat.update
          token: ${{ secrets.CI_SLACK_BOT_TOKEN }}
          payload: |
            channel: ${{ vars.SLACK_RELEASE_CHANNEL_ID }}
            ts: "${{ steps.slack-start.outputs.ts }}"
            text: "*CLI* publishing to npm...\n:white_check_mark: Published successfully"

      - name: Notify Slack - Failure
        if: ${{ failure() && steps.slack-start.outputs.ts }}
        uses: slackapi/slack-github-action@v2.1.1
        with:
          method: chat.update
          token: ${{ secrets.CI_SLACK_BOT_TOKEN }}
          payload: |
            channel: ${{ vars.SLACK_RELEASE_CHANNEL_ID }}
            ts: "${{ steps.slack-start.outputs.ts }}"
            text: "*CLI* publishing to npm...\n:x: Publish failed"

  publish-runner-npm:
    needs: release-please
    if: ${{ needs.release-please.outputs.runner_release_created == 'true' }}
    runs-on: ubuntu-latest
    environment: npm
    permissions:
      contents: read
      id-token: write
    steps:
      - uses: actions/checkout@v6

      - name: Notify Slack - Starting
        id: slack-start
        if: ${{ vars.SLACK_RELEASE_CHANNEL_ID != '' }}
        uses: slackapi/slack-github-action@v2.1.1
        with:
          method: chat.postMessage
          token: ${{ secrets.CI_SLACK_BOT_TOKEN }}
          payload: |
            channel: ${{ vars.SLACK_RELEASE_CHANNEL_ID }}
            text: "*Runner* publishing to npm..."

      - uses: actions/setup-node@v6
        with:
          node-version: lts/*
          registry-url: 'https://registry.npmjs.org'

      - name: Install pnpm
        run: npm install -g pnpm@latest

      - name: Install dependencies
        run: cd turbo && pnpm install --frozen-lockfile

      - name: Use latest npm for OIDC support
        run: npm install -g npm@latest

      - name: Build Core Package
        run: cd turbo && pnpm turbo run build --filter=@vm0/core

      - name: Build Runner
        run: cd turbo && pnpm --filter @vm0/runner build

      - name: Publish to npm with OIDC
        run: cd turbo/apps/runner/dist && npm publish --access public

      - name: Notify Slack - Success
        if: ${{ success() && steps.slack-start.outputs.ts }}
        uses: slackapi/slack-github-action@v2.1.1
        with:
          method: chat.update
          token: ${{ secrets.CI_SLACK_BOT_TOKEN }}
          payload: |
            channel: ${{ vars.SLACK_RELEASE_CHANNEL_ID }}
            ts: "${{ steps.slack-start.outputs.ts }}"
            text: "*Runner* publishing to npm...\n:white_check_mark: Published successfully"

      - name: Notify Slack - Failure
        if: ${{ failure() && steps.slack-start.outputs.ts }}
        uses: slackapi/slack-github-action@v2.1.1
        with:
          method: chat.update
          token: ${{ secrets.CI_SLACK_BOT_TOKEN }}
          payload: |
            channel: ${{ vars.SLACK_RELEASE_CHANNEL_ID }}
            ts: "${{ steps.slack-start.outputs.ts }}"
            text: "*Runner* publishing to npm...\n:x: Publish failed"

  # Deploy runner to production metal instances
  deploy-runner-production:
    needs: [release-please, publish-runner-npm]
    if: ${{ needs.release-please.outputs.runner_release_created == 'true' }}
    runs-on: ubuntu-latest
    container:
      image: ghcr.io/vm0-ai/vm0-toolchain-rust:20260203
    permissions:
      contents: read
    environment: production
    steps:
      - uses: actions/checkout@v6
      - uses: ./.github/actions/toolchain-init

      - name: Install Python3 and Ansible
        run: |
          apt-get update && apt-get install -y python3 python3-pip
          pip3 install ansible

      - name: Notify Slack - Starting
        id: slack-start
        if: ${{ vars.SLACK_RELEASE_CHANNEL_ID != '' }}
        uses: slackapi/slack-github-action@v2.1.1
        with:
          method: chat.postMessage
          token: ${{ secrets.CI_SLACK_BOT_TOKEN }}
          payload: |
            channel: ${{ vars.SLACK_RELEASE_CHANNEL_ID }}
            text: "*Runner* deploying to production servers..."

      - name: Build Core Package
        run: cd turbo && pnpm turbo run build --filter=@vm0/core

      # Cross-compile Rust binaries for ARM64 (metal runners are ARM64)
      - name: Build guest-init and guest-download for ARM64
        run: |
          cd crates
          CARGO_TARGET_AARCH64_UNKNOWN_LINUX_MUSL_LINKER=aarch64-linux-gnu-gcc \
            cargo build --release --target aarch64-unknown-linux-musl -p guest-init -p guest-download
          ls -la target/aarch64-unknown-linux-musl/release/guest-init
          ls -la target/aarch64-unknown-linux-musl/release/guest-download

      - name: Build runner bundle
        run: |
          # Build runner (use subshell to preserve working directory)
          (cd turbo && pnpm --filter @vm0/runner build)

          # Create staging directory with built files
          STAGING_DIR="/tmp/vm0-runner-bundle"
          rm -rf "$STAGING_DIR"
          mkdir -p "$STAGING_DIR"
          cp -r turbo/apps/runner/dist/* "$STAGING_DIR/"

          # Install production dependencies
          (cd "$STAGING_DIR" && npm install --omit=dev)

          # Create tarball
          tar -czf /tmp/vm0-runner-bundle.tar.gz -C /tmp vm0-runner-bundle

          echo "Bundle created at /tmp/vm0-runner-bundle.tar.gz"
          ls -lh /tmp/vm0-runner-bundle.tar.gz

      - name: Deploy to production with Ansible
        env:
          AWS_METAL_RUNNER_HOSTS: ${{ secrets.AWS_METAL_RUNNER_HOSTS }}
          AWS_METAL_RUNNER_USER: ${{ vars.AWS_METAL_RUNNER_USER }}
          AWS_METAL_RUNNER_SSH_KEY: ${{ secrets.AWS_METAL_RUNNER_SSH_KEY }}
          OFFICIAL_RUNNER_SECRET: ${{ secrets.OFFICIAL_RUNNER_SECRET }}
        run: |
          # Setup SSH key
          mkdir -p ~/.ssh
          echo "$AWS_METAL_RUNNER_SSH_KEY" > ~/.ssh/prod-runner.pem
          chmod 600 ~/.ssh/prod-runner.pem

          # Run Ansible playbook with rolling deployment
          cd ansible
          ansible-playbook \
            -i "${AWS_METAL_RUNNER_HOSTS}," \
            playbooks/deploy-runner.yml \
            --private-key ~/.ssh/prod-runner.pem \
            -e "ansible_user=${AWS_METAL_RUNNER_USER}" \
            -e "official_runner_secret=${OFFICIAL_RUNNER_SECRET}" \
            -e "api_url=https://www.vm0.ai" \
            -e "runner_bundle_path=/tmp/vm0-runner-bundle.tar.gz" \
            -v

      - name: Notify Slack - Success
        if: ${{ success() && steps.slack-start.outputs.ts }}
        uses: slackapi/slack-github-action@v2.1.1
        with:
          method: chat.update
          token: ${{ secrets.CI_SLACK_BOT_TOKEN }}
          payload: |
            channel: ${{ vars.SLACK_RELEASE_CHANNEL_ID }}
            ts: "${{ steps.slack-start.outputs.ts }}"
            text: "*Runner* deploying to production servers...\n:white_check_mark: Deployed successfully"

      - name: Notify Slack - Failure
        if: ${{ failure() && steps.slack-start.outputs.ts }}
        uses: slackapi/slack-github-action@v2.1.1
        with:
          method: chat.update
          token: ${{ secrets.CI_SLACK_BOT_TOKEN }}
          payload: |
            channel: ${{ vars.SLACK_RELEASE_CHANNEL_ID }}
            ts: "${{ steps.slack-start.outputs.ts }}"
            text: "*Runner* deploying to production servers...\n:x: Deploy failed"

  # Build E2B templates to production account
  # Uses production environment E2B_API_KEY secret
  build-e2b-template-production:
    needs: [release-please]
    # Build when any release is created
    if: ${{ needs.release-please.outputs.releases_created == 'true' }}
    runs-on: ubuntu-latest
    container:
      image: ghcr.io/vm0-ai/vm0-toolchain:20260203
    permissions:
      contents: read
    environment: production
    steps:
      - uses: actions/checkout@v6
      - uses: ./.github/actions/toolchain-init

      - name: Build E2B templates
        working-directory: turbo
        env:
          E2B_API_KEY: ${{ secrets.E2B_API_KEY }}
        run: |
          pnpm e2b:build
          pnpm e2b:codex:build
          pnpm e2b:claude-code-github:build
          pnpm e2b:cli:build

      - name: Build summary
        run: echo "âœ… E2B templates built successfully (production account)"

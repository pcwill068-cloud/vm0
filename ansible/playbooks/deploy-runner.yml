# Deploy VM0 Runner
#
# This playbook deploys the VM0 runner to metal instances.
# Supports both CI (PR testing) and Production deployments.
#
# CI Usage - Full deployment (single host, no drain):
#   ansible-playbook -i "host," playbooks/deploy-runner.yml \
#     -e "ansible_user=ubuntu" \
#     -e "runner_base_dir=/opt/vm0-runner/pr-123" \
#     -e "runner_group=vm0/development-pr-123" \
#     -e "pm2_process_name=vm0-runner-pr-123" \
#     -e "official_runner_secret=xxx" \
#     -e "api_url=https://preview-url.vercel.app" \
#     -e "enable_drain=false"
#
# CI Usage - Prepare only (no api_url needed):
#   ansible-playbook -i "host," playbooks/deploy-runner.yml --tags prepare \
#     -e "ansible_user=ubuntu" \
#     -e "runner_base_dir=/opt/vm0-runner/pr-123" \
#     -e "runner_bundle_path=/tmp/vm0-runner-bundle.tar.gz" \
#     -e "enable_drain=false"
#
# CI Usage - Start only (requires api_url):
#   ansible-playbook -i "host," playbooks/deploy-runner.yml --tags start \
#     -e "ansible_user=ubuntu" \
#     -e "runner_base_dir=/opt/vm0-runner/pr-123" \
#     -e "runner_group=vm0/development-pr-123" \
#     -e "pm2_process_name=vm0-runner-pr-123" \
#     -e "official_runner_secret=xxx" \
#     -e "api_url=https://preview-url.vercel.app"
#
# Production Usage (multiple hosts, with drain):
#   ansible-playbook -i "host1,host2," playbooks/deploy-runner.yml \
#     -e "ansible_user=ubuntu" \
#     -e "official_runner_secret=xxx" \
#     -e "api_url=https://www.vm0.ai" \
#     -e "enable_drain=true"
#
# Tags:
#   - prepare: Phases 1-4 (stop, deploy bundle, install deps) - no api_url needed
#   - start: Phases 5-6 (configure, start, health check) - requires api_url
#   - (no tags): Run all phases
#
# Required Variables:
#   - For prepare: runner_bundle_path
#   - For start: official_runner_secret, api_url
#   - For full: all of the above
#
# Optional Variables (with defaults):
#   - runner_base_dir: Runner installation directory (default: /opt/vm0-runner/production)
#   - runner_group: Runner group name (default: vm0/production)
#   - pm2_process_name: PM2 process name (default: vm0-runner-production)
#   - enable_drain: Whether to drain before stopping (default: true)
#   - drain_timeout: Max seconds to wait for drain (default: 86400 = 24h)
#   - extra_env: Additional environment variables as JSON (default: {})

- name: Deploy VM0 Runner
  hosts: all
  serial: 1  # Rolling update: one host at a time (no effect for single host)
  become: yes

  vars:
    # Defaults for production - CI should override these
    runner_base_dir: /opt/vm0-runner/production
    runner_group: vm0/production
    pm2_process_name: vm0-runner-production
    enable_drain: true
    drain_timeout: 86400  # 24 hours
    extra_env: {}
    # Rootfs configuration - CI should override for per-PR isolation
    rootfs_path: /opt/firecracker/rootfs.squashfs
    force_rebuild_rootfs: false
    # Proxy port - CI should override for per-PR isolation (8080 + PR_NUMBER % 1000)
    proxy_port: 8080

  tasks:
    # ========================================
    # Phase 1: Pre-flight checks
    # ========================================
    - name: Check required variables for prepare phase
      assert:
        that:
          - runner_bundle_path is defined
        fail_msg: "Required variable for prepare: runner_bundle_path"
      tags: [prepare]

    - name: Check required variables for start phase
      assert:
        that:
          - official_runner_secret is defined
          - api_url is defined
        fail_msg: "Required variables for start: official_runner_secret, api_url"
      tags: [start]

    - name: Display prepare configuration
      debug:
        msg: |
          Preparing runner:
          - Directory: {{ runner_base_dir }}
          - Bundle: {{ runner_bundle_path }}
          - Drain enabled: {{ enable_drain }}
      tags: [prepare]

    - name: Display start configuration
      debug:
        msg: |
          Starting runner:
          - Directory: {{ runner_base_dir }}
          - Group: {{ runner_group }}
          - Process: {{ pm2_process_name }}
          - API: {{ api_url }}
      tags: [start]

    # ========================================
    # Phase 2: Stop existing runner
    # ========================================
    - name: Check if runner is currently running
      shell: pm2 jlist 2>/dev/null | jq -r '.[] | select(.name=="{{ pm2_process_name }}") | .pid // empty'
      register: pm2_pid
      ignore_errors: yes
      changed_when: false
      become: no
      tags: [prepare]

    # Production: Drain before stopping (wait for active jobs)
    # Note: regex must match positive integers only (not '0' which would signal process group)
    - name: Enter maintenance mode (stop polling, wait for active jobs)
      when: enable_drain and pm2_pid.stdout | regex_search('^[1-9][0-9]*$')
      tags: [prepare]
      block:
        - name: Signal runner to enter drain mode
          command: kill -USR1 {{ pm2_pid.stdout }}

        - name: Wait for active jobs to complete
          shell: |
            # Poll status file until active_jobs is 0 or timeout
            timeout={{ drain_timeout }}
            elapsed=0
            status_file="{{ runner_base_dir }}/status.json"

            while [ $elapsed -lt $timeout ]; do
              if [ -f "$status_file" ]; then
                # Check mode and active_jobs from JSON (handle pretty-printed format with spaces)
                mode=$(cat "$status_file" | grep -o '"mode": *"[^"]*"' | cut -d'"' -f4)
                active=$(cat "$status_file" | grep -o '"active_jobs": *[0-9]*' | grep -o '[0-9]*')

                if [ "$active" = "0" ]; then
                  echo "Drain complete: no active jobs (mode: $mode)"
                  exit 0
                fi
                echo "Draining: $active active job(s), mode: $mode (${elapsed}s elapsed)"
              else
                echo "Status file not found yet, waiting..."
              fi
              sleep 10
              elapsed=$((elapsed + 10))
            done

            echo "Drain timeout after ${timeout}s"
            exit 1
          args:
            executable: /bin/bash
          register: drain_result

        - name: Stop runner after drain
          command: pm2 delete {{ pm2_process_name }}
          ignore_errors: yes
          become: no

    # CI: Just stop without drain (no long-running jobs)
    - name: Stop runner without drain
      when: not enable_drain and pm2_pid.stdout | regex_search('^[1-9][0-9]*$')
      command: pm2 delete {{ pm2_process_name }}
      ignore_errors: yes
      become: no
      tags: [prepare]

    # ========================================
    # Phase 3: Deploy
    # ========================================
    - name: Ensure runner directory exists
      file:
        path: "{{ runner_base_dir }}"
        state: directory
        owner: "{{ ansible_user }}"
        group: "{{ ansible_user }}"
        mode: '0755'
      tags: [prepare]

    - name: Clean runner directory
      shell: rm -rf {{ runner_base_dir }}/*
      tags: [prepare]

    - name: Extract runner bundle
      unarchive:
        src: "{{ runner_bundle_path }}"
        dest: "{{ runner_base_dir }}"
        owner: "{{ ansible_user }}"
        group: "{{ ansible_user }}"
        extra_opts: [--strip-components=1]
      tags: [prepare]

    - name: Ensure deploy-runner directory exists
      file:
        path: "{{ runner_base_dir }}/deploy-runner"
        state: directory
        owner: "{{ ansible_user }}"
        group: "{{ ansible_user }}"
        mode: '0755'
      tags: [prepare]

    - name: Copy deploy scripts
      copy:
        src: "{{ item }}"
        dest: "{{ runner_base_dir }}/deploy-runner/"
        owner: "{{ ansible_user }}"
        group: "{{ ansible_user }}"
        mode: '0755'
      with_fileglob:
        - "{{ playbook_dir }}/../../turbo/apps/runner/scripts/deploy/*.sh"
      tags: [prepare]

    - name: Copy Dockerfile for rootfs build
      copy:
        src: "{{ playbook_dir }}/../../turbo/apps/runner/scripts/deploy/Dockerfile"
        dest: "{{ runner_base_dir }}/deploy-runner/Dockerfile"
        owner: "{{ ansible_user }}"
        group: "{{ ansible_user }}"
        mode: '0644'
      tags: [prepare]

    # ========================================
    # Phase 4: Install Dependencies (if needed)
    # ========================================
    - name: Check if Firecracker is installed
      stat:
        path: /usr/local/bin/firecracker
      register: firecracker_bin
      tags: [prepare]

    - name: Install Firecracker
      command: "{{ runner_base_dir }}/deploy-runner/install-firecracker.sh"
      when: not firecracker_bin.stat.exists
      tags: [prepare]

    - name: Check if mitmproxy is installed
      command: mitmdump --version
      register: mitmproxy_check
      ignore_errors: yes
      changed_when: false
      tags: [prepare]

    - name: Install pipx for mitmproxy
      apt:
        name: pipx
        state: present
      when: mitmproxy_check.rc != 0
      tags: [prepare]

    - name: Install mitmproxy via pipx
      command: pipx install mitmproxy
      environment:
        PIPX_HOME: /opt/pipx
        PIPX_BIN_DIR: /usr/local/bin
      when: mitmproxy_check.rc != 0
      tags: [prepare]

    - name: Check if rootfs exists
      stat:
        path: "{{ rootfs_path }}"
      register: rootfs_file
      tags: [prepare]

    # Calculate hash of all files that affect rootfs content
    - name: Calculate rootfs build inputs hash
      shell: |
        cat "{{ runner_base_dir }}/deploy-runner/Dockerfile" \
            "{{ runner_base_dir }}/deploy-runner/overlay-init.sh" \
            "{{ runner_base_dir }}/deploy-runner/build-rootfs.sh" \
        | sha256sum | cut -d' ' -f1
      register: rootfs_inputs_hash
      changed_when: false
      tags: [prepare]

    - name: Read stored rootfs hash
      slurp:
        src: "{{ rootfs_path }}.sha256"
      register: stored_rootfs_hash
      ignore_errors: yes
      tags: [prepare]

    - name: Determine if rootfs rebuild is needed
      set_fact:
        rootfs_needs_rebuild: >-
          {{
            not rootfs_file.stat.exists or
            force_rebuild_rootfs or
            stored_rootfs_hash.failed or
            (stored_rootfs_hash.content | default('') | b64decode | trim) != rootfs_inputs_hash.stdout
          }}
      tags: [prepare]

    - name: Build rootfs
      command: "{{ runner_base_dir }}/deploy-runner/build-rootfs.sh {{ rootfs_path }}"
      when: rootfs_needs_rebuild
      tags: [prepare]

    - name: Store rootfs hash
      copy:
        content: "{{ rootfs_inputs_hash.stdout }}\n"
        dest: "{{ rootfs_path }}.sha256"
        mode: '0644'
      when: rootfs_needs_rebuild
      tags: [prepare]

    - name: Check if proxy CA certificate exists
      stat:
        path: "{{ runner_base_dir }}/deploy-runner/proxy-ca/mitmproxy-ca.pem"
      register: proxy_ca_file
      tags: [prepare]

    - name: Generate proxy CA certificate if not exists
      command: "{{ runner_base_dir }}/deploy-runner/generate-proxy-ca.sh {{ runner_base_dir }}/deploy-runner/proxy-ca"
      when: not proxy_ca_file.stat.exists
      tags: [prepare]

    - name: Ensure proxy CA directory exists
      file:
        path: /opt/vm0-runner/proxy
        state: directory
        owner: "{{ ansible_user }}"
        group: "{{ ansible_user }}"
        mode: '0755'
      tags: [prepare]

    - name: Copy proxy CA (cert+key) for mitmproxy
      copy:
        src: "{{ runner_base_dir }}/deploy-runner/proxy-ca/mitmproxy-ca.pem"
        dest: /opt/vm0-runner/proxy/mitmproxy-ca.pem
        owner: "{{ ansible_user }}"
        group: "{{ ansible_user }}"
        mode: '0600'
        remote_src: yes
      tags: [prepare]

    - name: Copy proxy CA certificate (cert only) for VM installation
      copy:
        src: "{{ runner_base_dir }}/deploy-runner/proxy-ca/mitmproxy-ca-cert.pem"
        dest: /opt/vm0-runner/proxy/mitmproxy-ca-cert.pem
        owner: "{{ ansible_user }}"
        group: "{{ ansible_user }}"
        mode: '0644'
        remote_src: yes
      tags: [prepare]

    - name: Ensure user is in kvm group for Firecracker
      user:
        name: "{{ ansible_user }}"
        groups: kvm
        append: yes
      register: kvm_group_result
      tags: [prepare]

    - name: Reset connection to pick up new group membership
      meta: reset_connection
      when: kvm_group_result.changed
      tags: [prepare]

    # Kill PM2 daemon so it restarts with new group membership
    # PM2 child processes inherit the daemon's groups, not the shell's groups
    - name: Kill PM2 daemon to pick up kvm group
      command: pm2 kill
      become: no
      ignore_errors: yes
      when: kvm_group_result.changed
      tags: [prepare]

    # ========================================
    # Phase 5: Configure and Start
    # ========================================
    - name: Generate runner configuration
      template:
        src: runner.yaml.j2
        dest: "{{ runner_base_dir }}/runner.yaml"
        owner: "{{ ansible_user }}"
        group: "{{ ansible_user }}"
        mode: '0600'
      tags: [start]

    - name: Create PM2 ecosystem file
      template:
        src: ecosystem.config.cjs.j2
        dest: "{{ runner_base_dir }}/ecosystem.config.cjs"
        owner: "{{ ansible_user }}"
        group: "{{ ansible_user }}"
        mode: '0644'
      tags: [start]

    - name: Start runner via PM2
      command: pm2 start ecosystem.config.cjs
      args:
        chdir: "{{ runner_base_dir }}"
      become: no
      environment: "{{ extra_env }}"
      tags: [start]

    - name: Save PM2 process list
      command: pm2 save
      become: no
      tags: [start]

    # ========================================
    # Phase 6: Health Check
    # ========================================
    - name: Wait for runner to be ready
      wait_for:
        path: /tmp/{{ pm2_process_name }}.log
        search_regex: "Press Ctrl\\+C to stop"
        timeout: 120
      tags: [start]

    - name: Verify runner is polling
      shell: pm2 jlist | jq -r '.[] | select(.name=="{{ pm2_process_name }}") | .pm2_env.status'
      register: pm2_status
      failed_when: pm2_status.stdout != "online"
      become: no
      tags: [start]

    - name: Verify runner can connect to API
      command: node index.js status --config ./runner.yaml
      args:
        chdir: "{{ runner_base_dir }}"
      become: no
      environment: "{{ extra_env }}"
      register: status_check
      retries: 3
      delay: 5
      until: status_check.rc == 0
      tags: [start]

    - name: Display deployment summary
      debug:
        msg: |
          âœ“ Runner deployed successfully on {{ inventory_hostname }}
          - Process: {{ pm2_process_name }}
          - Group: {{ runner_group }}
          - API: {{ api_url }}
          - Directory: {{ runner_base_dir }}
      tags: [start]
